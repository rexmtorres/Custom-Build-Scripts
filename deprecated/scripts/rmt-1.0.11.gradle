/**
 * Helper functions to help set up Gradle tasks for commonly used procedures.  To use this in your
 * AS projects, import this script into your module by adding:
 *     apply from: '<absolute_path_to_script>/rmt-<version>.gradle
 *
 * Example:
 *     apply from: 'scripts/rmt-1.0.0.gradle'
 *
 * This will make the following functions available:
 *     + renameOutputFile - Copies and renames the output APK/AAR into a specified folder.  If the
 *                          module is a library module (AAR), a JAR file will also be generated and
 *                          put into the output folder.
 *     + unsignApk - Removes the signature of a signed APK.
 *     + exportApkProguardMapping - Copies the Proguard map files into a specified folder.
 *     + createJavaDoc - Generates JavaDoc w/ UML diagrams from the specified source files.
 *     + calculateLinesOfCode - Generates step count of the source code using Amateras StepCounter.
 * 
 * Original author    : Rex M. Torres
 * Creation date      : 07 March 2016
 */
 
ext.cdnRoot = "https://rexmtorres.github.io/Packager/deprecated"
ext.binVersion = "v1"
ext.cacheRoot = "${System.getProperty("user.home")}/.gradle/rmtcache/${binVersion}"

println "WARNING:  This script is deprecated and will soon be removed."
println "Please consider using Packager Plugin (https://rexmtorres.github.io/Packager/docs/) instead."

def downloadBin() {
    def url = new URL("${cdnRoot}/bin_${binVersion}.zip")
    def localFile = new File("${cacheRoot}/bin.zip")
    def localRoot = localFile.parentFile

    if (!localRoot.exists()) {
        localRoot.mkdirs()
    }

    url.withInputStream { ins ->
        localFile.withOutputStream { ous -> ous << ins }
    }

    copy {
        from zipTree(localFile)
        into localRoot
    }
}

def binFile(location) {
    def localFile = new File(location)

    println "File => ${localFile}"

    if (localFile.exists()) {
        println "Local cache exists!  Reusing..."
        return localFile
    }

    println "Local cache does not exist!  Downloading..."
    downloadBin()

    return localFile
}

// -------------------------------------------------------------------------------------------------
// START: CUSTOM SCRIPTS
// -------------------------------------------------------------------------------------------------
import org.apache.tools.ant.taskdefs.condition.Os

def COMMON_TOOLS = "${cacheRoot}/bin"

configurations {
    yDoclet
}

/**
 * <p>
 * Moves and renames the output file to a specified folder.
 *
 * <p>
 * For library projects, a JAR file will also be generated in addition to the AAR file.
 *
 * @param project The project/module that is being processed.
 * @param output The build variant in the module that is being built.
 * @param newName New name of the file.
 * @param outputDir Directory where the final output file will be placed
 * @return The new file name
 */
ext.renameOutputFile = { /* Project */ project, /* BaseVariantOutput */ output, /* String */ newName, /* String */ outputDir ->
    println("+renameOutputFile(\n" +
            "\tproject: [${project}],\n" +
            "\toutput: [${output}],\n" +
            "\tnewName: [${newName}],\n" +
            "\toutputDir: [${outputDir}])")

    def checkDir = new File("${project.buildDir}/intermediates/classes/${output.dirName}")
    def newFileName = ""

    println(" \tCheck dir: ${checkDir}")

    // 09Jun2016 - remove the checkDir check as it causes some tasks to be skipped.
    // checkDir was needed before when the task dependencies were not yet properly set
    // causing them to be prematurely configured/executed.
    //if(checkDir.exists()) {
    if(true) {    // TODO: when we're sure we don't need checkDir check anymore, move the code out of this block.
        def libVariant
        def file

        try {
            if(output.zipAlign) {
                file = output.outputFile
            } else {
                file = output.packageApplication.outputFile
            }

            libVariant = false
        } catch(Exception e) {    // for LibraryVariants
            file = output.outputFile
            libVariant = true
        }

        def oldName = file.name
        def ext = ""
        def index = file.name.lastIndexOf('.')

        if(index > 0) {
            ext = file.name.substring(index);
        }

        println(" \textension: ${ext}")
        println(" \told name: ${oldName}")

        // rename the file (duh)
        newFileName = file.name.replace("${oldName}", "${newName}${ext}")

        println "new name: ${newFileName}"

        def distDir = new File(outputDir)
        def varName = output.name.capitalize()

        if(!libVariant) {
            File outApk = null

//            if(output.zipAlign) {
//                output.outputFile = new File(distDir, newFileName)
//            } else {
//                output.packageApplication.outputFile = new File(distDir, newFileName)
//            }

            println "rmtCopyApk${varName}> output.zipAlign: ${output.zipAlign}..."

            if(output.zipAlign) {
                outApk = output.outputFile
            } else {
                outApk = output.packageApplication.outputFile
            }

            project.task("rmtCopyApk${varName}", type: Copy) {
				group "RMT"
				
                if(output.zipAlign) {
                    dependsOn project.tasks["zipalign${varName}"]
                    mustRunAfter project.tasks["zipalign${varName}"]
                } else {
                    dependsOn project.tasks["package${varName}"]
                    mustRunAfter project.tasks["package${varName}"]
                }
            
                if(!distDir.exists()) {
                    distDir.mkdirs()
                }

                def dest = new File(distDir, newFileName)

                println "rmtCopyApk${varName}> Source: ${outApk.absolutePath}..."
                println "rmtCopyApk${varName}> Source exits: ${outApk.exists()}"
                println "rmtCopyApk${varName}> Destination: ${dest.absolutePath}..."
                println "rmtCopyApk${varName}> Destination exits: ${dest.exists()}"

                outputs.upToDateWhen {dest.exists()}
                inputs.file outApk
                outputs.file dest

                println "rmtCopyApk${varName}> Saving ${newFileName} to ${distDir.absolutePath}..."

                from("${outApk.absolutePath}")
                into(distDir)
                rename(outApk.name, newFileName)
            }
            
            project.tasks["assemble${varName}"].dependsOn project.tasks["rmtCopyApk${varName}"]
        } else {
            // For LibraryVariants, extract the JAR file from the AAR file and export it to the
            // output folder (in addition to the AAR file).  AAR file is only supported in Android
            // Studio; we still need the JAR file for Eclipse.

            output.outputFile = new File(distDir, newFileName)

            def explodedAar = new File("${project.buildDir}/tmp.exploded-aar/${output.dirName}")
            def jarFileName = newFileName.replace(".aar", ".jar")

            // Extract the classes.jar file inside the AAR file and rename it to the variant name.
            project.task("rmtExtractJar${varName}", type: Copy) {
                dependsOn project.tasks["bundle${varName}"]
                mustRunAfter project.tasks["bundle${varName}"]
                
                from zipTree(output.outputFile)
                into(explodedAar)
                rename("classes.jar", jarFileName)
            }

            // Copy the extracted JAR file into the output directory.
            project.task("rmtCopyJar${varName}", type: Copy) {
				group "RMT"
				
                dependsOn project.tasks["rmtExtractJar${varName}"]
                mustRunAfter project.tasks["rmtExtractJar${varName}"]
                
                from("${explodedAar.absolutePath}/${jarFileName}")
                into(output.outputFile.parentFile)
            }

            project.tasks["assemble${varName}"].dependsOn project.tasks["rmtCopyJar${varName}"]
        }

        println(" \tOutput: ${newFileName}")
    }
    
    //project.tasks.matching { task ->
    //    task.name.startsWith('rmt')
    //}*.group = 'RMT'
    
    println("-renameOutputFile")
    println("---------------------------------------------------------------------------------")
    return newFileName
}

/**
 * <p>
 * "Unsigns" the specified APK by removing the META-INF folder inside it, which contains the signature(s).
 *
 * @param project The project/module that is being processed.
 * @param variant The build variant in the module that is being built.
 * @param apkIn The signed APK to be unsigned.
 * @param apkOut The unsigned APK to be generated.  May be set to <code>null</code>,
 *               in which case, apkIn will be overwritten with the generated unsigned APK.
 */
ext.unsignApk = { /* Project */ project, /* BaseVariant */ variant, /* String */ apkIn, /* String */ apkOut ->
    println("+unsignApk(\n" +
            "\tproject: [${project}],\n" +
            "\tvariant: [${variant.name}: ${variant}],\n" +
            "\tapkIn: [${apkIn}],\n" +
            "\tapkOut: [${apkOut}])")
    String varName = variant.name.capitalize()

    def fApkIn = file(apkIn)
    def fApkOut

    // If apkOut is null, use apkIn as output
    if(apkOut == null) {
        fApkOut = file(apkIn)
    } else {
        fApkOut = file(apkOut)
    }

    def unpacked = file("${project.buildDir}/tmp/unpacked/${variant.dirName}")
    def metaInf = file("${project.buildDir}/tmp/unpacked/${variant.dirName}/META-INF")

    // Delete any old files in the temp folder
    project.task("rmtUnsignApk${varName}00DeleteTmp", type: Delete) {
        try {
            dependsOn project.tasks["rmtCopyApk${varName}"]
            mustRunAfter project.tasks["rmtCopyApk${varName}"]
        } catch(Exception e) {
            println "rmtCopyApk${varName} does not exist!"
            dependsOn project.tasks["package${varName}"]
            mustRunAfter project.tasks["package${varName}"]
        }
    
        outputs.upToDateWhen {false}

        doLast {
            println("rmtUnsignApk${varName}00DeleteTmp> Unpacked: ${unpacked}")
        }

        if(unpacked.exists()) {
            doLast {
                println("rmtUnsignApk${varName}00DeleteTmp> Deleting: ${unpacked}")
            }

            delete unpacked
        }
    }

    // Unzip the APK into a temp folder
    //project.task("rmtUnsignApk${varName}01Unpack", type: Copy) {
    project.task("rmtUnsignApk${varName}01Unpack") {
        dependsOn project.tasks["rmtUnsignApk${varName}00DeleteTmp"]
        mustRunAfter project.tasks["rmtUnsignApk${varName}00DeleteTmp"]
    
        outputs.upToDateWhen {false}

        doLast {
            if(fApkIn.exists() && fApkIn.isFile() && fApkIn.absolutePath.toLowerCase().endsWith(".apk")) {
                println("rmtUnsignApk${varName}01Unpack> Unpacking ${fApkIn.absolutePath} ${unpacked}")

                copy {
                    from zipTree(fApkIn)
                    into unpacked
                }
            } else {
                println("rmtUnsignApk${varName}01Unpack> ${fApkIn.absolutePath} is not a valid APK!  Task skipped!")
            }
        }
    }

    // Delete the META-INF folder containing the signature(s)
    project.task("rmtUnsignApk${varName}02DeleteCert", type: Delete) {
        dependsOn project.tasks["rmtUnsignApk${varName}01Unpack"]
        mustRunAfter project.tasks["rmtUnsignApk${varName}01Unpack"]
    
        outputs.upToDateWhen {false}

        doLast {
            println("rmtUnsignApk${varName}02DeleteCert> META-INF: ${metaInf}")
            println("rmtUnsignApk${varName}02DeleteCert> Deleting: ${metaInf}")
        }

        delete metaInf
    }

    // Zip the files back from the temp folder
    def arcPath = file("${variant.dirName}/unsigned.apk")

    // These force task "rmtUnsignApk${varName}" to always be executed.
    // Without them, the task will be skipped.
    def task04Input = file("${project.buildDir}/tmp/rmtUnsignApk${varName}.in")
    def task04Output = file("${project.buildDir}/tmp/rmtUnsignApk${varName}.out")

    project.task("rmtUnsignApk${varName}03Zip", type: Zip) {
        dependsOn project.tasks["rmtUnsignApk${varName}02DeleteCert"]
        mustRunAfter project.tasks["rmtUnsignApk${varName}02DeleteCert"]
    
        outputs.upToDateWhen {false}

        baseName "${variant.dirName}/unsigned.apk"
        from unpacked

        doLast {
            println("rmtUnsignApk${varName}03Zip> Unpacked: ${unpacked}")
            println("rmtUnsignApk${varName}03Zip> Base Name: ${baseName}")
            println("rmtUnsignApk${varName}03Zip> Zipped ${unpacked} to ${archivePath}")

            arcPath = file(archivePath)

            if(!task04Input.exists()) {
                task04Input.createNewFile();
            }

            if(task04Input.exists()) {
                task04Input.write("timestamp " + System.currentTimeMillis());
            }
        }
    }

    // Copy the unsigned APK into the final output APK
    //project.task("rmtUnsignApk${varName}04Copy", type: Copy) {
    project.task("rmtUnsignApk${varName}") {
		group "RMT"
		
        dependsOn project.tasks["rmtUnsignApk${varName}03Zip"]
        mustRunAfter project.tasks["rmtUnsignApk${varName}03Zip"]

        outputs.upToDateWhen {false}

        inputs.file task04Input
        outputs.file task04Output

        doLast {
            println("rmtUnsignApk${varName}> Packed: ${arcPath}")
            println("rmtUnsignApk${varName}> Copying ${arcPath} to ${fApkOut}")

            if(!task04Output.exists()) {
                task04Output.createNewFile();
            }

            if(task04Output.exists()) {
                task04Output.write("timestamp " + System.currentTimeMillis());
            }

            copy {
                from arcPath
                into fApkOut.parentFile

                rename arcPath.name, fApkOut.name
            }
        }
    }

    project.tasks["assemble${varName}"].dependsOn project.tasks["rmtUnsignApk${varName}"]
    
    //project.tasks.matching { task ->
    //    task.name.startsWith('rmt')
    //}*.group = 'RMT'

    println("-unsignApk")
}

/**
 * <p>
 * Creates an "exportMap${variant}" task, for the specified variant in the specified project/module,
 * which will be executed after the "proguard${variant}" task.
 *
 * <p>
 * The "exportMap${variant}" task will attempt to copy the Proguard map files, from the module's
 * "build" folder, into the "Proguard" folder under the root project.
 *
 * @param project The project/module that is being processed.
 * @param variant The variant in the module that is being processed.
 * @param outputFolder The name of the folder where the map files will be placed.
 */
ext.exportApkProguardMapping = { /* Project */ project, /* BaseVariant */ variant, /* String */ outputFolder ->
    // Copy the proguard map files to the root directory under "Proguard"
    String varName = variant.name.capitalize()
    //varName = varName.substring(0, 1).toUpperCase() + varName.substring(1);

    def srcDir = "${project.buildDir}/outputs/mapping/${variant.dirName}"
//    def dstDir = "${project.rootProject.rootDir.absolutePath}/proguardMap/${project.name}/${outputFolder}"

    println("source: ${srcDir}")
    println("destination: ${outputFolder}")

    project.task("rmtExportMap${varName}", type: Copy) {
		group "RMT"
		
        // In Android Gradle plugin v2.1.0-alpha1, proguard${varName} has been replaced with transformClassesAndResourcesWithProguardFor${varName}
        // transformClassesAndResourcesWithProguardFor${varName} may be changed again in the future, but package${varName} seems to be unchanging.
        // So, we'll just use package${varName} instead as a "mustRunAfter" dependency for rmtExportMap${varName}.
        try {
            dependsOn project.tasks["proguard${varName}"]
            mustRunAfter project.tasks["proguard${varName}"]
        } catch(Exception e) {
            println "Task proguard${varName} not found: ${e}"
            
            if(project.tasks.findByPath("bundle${varName}") == null) {
                println "Linking to task package${varName} instead..."
                
                dependsOn project.tasks["package${varName}"]
                mustRunAfter project.tasks["package${varName}"]
            } else {
                println "Linking to task bundle${varName} instead..."
                
                dependsOn project.tasks["bundle${varName}"]
                mustRunAfter project.tasks["bundle${varName}"]
            }
        }
    
        from(srcDir)
        into(outputFolder)
    }

    project.tasks["assemble${varName}"].dependsOn project.tasks["rmtExportMap${varName}"]
    
    //project.tasks.matching { task ->
    //    task.name.startsWith('rmt')
    //}*.group = 'RMT'
}

/**
 * <p>
 * Generates the JavaDoc documentation of the specified variant of the specified project.
 *
 * <p>
 * Creates 4 tasks for the specified variant:
 * <ol>
 *     <li>rmtExcludeRes${variant} - Modifies R.java and Manifest.java to add "@y.exclude" yDoc
 *        JavaDoc tags to exclude them from the JavaDoc
 *     <li>rmtJavaDoc${variant} - Generates the JavaDoc with UML diagrams c/o the yDoc doclet
 *         (http://www.yworks.com/en/products_ydoc.html)
 *     <li>rmtSyntaxify${variant} - Beautifies source code samples in the JavaDoc by applying
 *         syntax highlighting using SyntaxHiglighter (http://alexgorbatchev.com/SyntaxHighlighter/)
 *     <li>rmtArchiveJavaDoc${variant} - Packages the generated JavaDoc into a ZIP file and puts
 *         the ZIP file into the root folder under "build/JavaDocs".
 * </ol>
 *
 * <p>
 * The 4 tasks are then executed in the order specified above.
 *
 * @param additionalSourceFiles Additional source files, which
 *                              may not be part of the project, but are referenced by the project.
 *                              Examples would be source codes of external libraries used by the project.
 * @param additionalClasspathFiles Additional files to be included
 *                                 in the classpath.  The variant's classpath, as well as the
 *                                 Android classpath are already automatically added by this script
 *                                 so there's no need to include them in this classpath.  Only
 *                                 additional paths, like OMAPI, or any other external paths that the
 *                                 project may be using.
 * @param project The project/module that is being processed.
 * @param variant The variant in the module that is being processed.
 * @param output The build variant in the module that is being processed.
 * @param javaDocTitle The title of the JavaDoc
 * @param javadocMemberLevel Indicates the member visibility to be used
 *                           (JavadocMemberLevel.PUBLIC, JavadocMemberLevel.PACKAGE,
 *                           JavadocMemberLevel.PROTECTED, JavadocMemberLevel.PRIVATE)
 * @param archiveName The name of the ZIP file containing the JavaDoc to be generated.
 * @param outputPath The directory where the zipped JavaDoc will be placed.
 * @param android The Android plugin
 */
ext.createJavaDoc = { /* ConfigurableFileCollection */ additionalSourceFiles, /* ConfigurableFileCollection */ additionalClasspathFiles,
                      /* Project */ project, /* BaseVariant */ variant, /* BaseVariantOutput */ output,
                      /* String */ javaDocTitle, /* JavadocMemberLevel */ javadocMemberLevel, /* String */ archiveName,
                      /* String */ outputPath, /* BaseExtension */ android ->
    def platformDir = getSdkPlatformFolder(android.sdkDirectory, android.compileSdkVersion)
    def varName = variant.name.capitalize()

    println "android.sdkDirectory type: " + android.sdkDirectory.class
    println "android.compileSdkVersion type: " + android.compileSdkVersion.class

    // Modifies the generated R.java and Manifest.java to add "@y.exclude" yDoc JavaDoc tags to
    // exclude them from the JavaDoc
    def resSource = "${project.buildDir}/generated/source/r/${output.dirName}"
    def resExcluded = "${project.buildDir}/r.excluded/source/r/${output.dirName}"

    project.task("rmtExcludeRes00${varName}", type: Copy) {
        dependsOn project.tasks["compile${varName}Sources"]
        mustRunAfter project.tasks["compile${varName}Sources"]
    
        outputs.upToDateWhen {false}

        from resSource
        into resExcluded
        include "**/Manifest.java"
        include "**/R.java"

        filter { String line ->
            line.replaceAll("/\\*.*?\\*/", "/* */").
                    replaceAll("(public)(\\s+)(\\S*)(\\s*)(final)(\\s+)",
                            "/** @y.exclude */ \$1\$2\$3\$4\$5\$6")
        }
    }

    project.task("rmtExcludeRes${varName}", type: Copy) {
        dependsOn project.tasks["rmtExcludeRes00${varName}"]
        mustRunAfter project.tasks["rmtExcludeRes00${varName}"]
    
        outputs.upToDateWhen {false}

        from resExcluded
        into resSource
        include "**/Manifest.java"
        include "**/R.java"
    }

    // Generates the JavaDoc with UML using yDoc doclet
    project.task("rmtJavaDoc${varName}", type: Javadoc) {
	    // if (Os.isFamily(Os.FAMILY_WINDOWS)) {
		// 	def osBit = System.properties['sun.arch.data.model']
		// 	executable = "$COMMON_TOOLS/javaDoc/jdk/win/${osBit}-bit/bin/javadoc.exe"
		// 	println "OS: Windows ${osBit}-bit"
		// 	println "Using bundled javadoc.exe (JDK 7u80)..."
		// 	println "   \"$executable\""
		// }
		
        dependsOn project.tasks["rmtExcludeRes${varName}"]
        mustRunAfter project.tasks["rmtExcludeRes${varName}"]
        
        title = javaDocTitle
        source = variant.javaCompile.source

        if(javadocMemberLevel == null) {
            javadocMemberLevel = JavadocMemberLevel.PROTECTED
        }

        if(additionalSourceFiles != null) {
            source += additionalSourceFiles
        }

        ext.androidJar = "${platformDir}/android.jar"
        ext.androidAnnotJar = "${android.sdkDirectory}/tools/support/annotations.jar"

        classpath = files(variant.javaCompile.classpath.files,
                ext.androidJar,
                ext.androidAnnotJar)

        if(additionalClasspathFiles != null) {
            classpath += additionalClasspathFiles
        }

        options {
            linksOffline("http://d.android.com/reference", "${android.sdkDirectory}/docs/reference")
        }

        destinationDir = new File("${project.buildDir}/javadoc/${archiveName}")
        
        File optionsFile = file("${project.rootProject.rootDir}/javadoc.options")
        
		if(!optionsFile.exists()) {
			println "Using default JavaDoc options..."
			// optionsFile = binFile("${COMMON_TOOLS}/javaDoc/javadoc_default.options") // file("${COMMON_TOOLS}/javaDoc/javadoc_default.options")
            optionsFile = binFile("${COMMON_TOOLS}/javaDoc/javadoc_default_noydoc.options") // file("${COMMON_TOOLS}/javaDoc/javadoc_default.options")
		}
		
		// options.docletpath = files(configurations.yDoclet.files,
		// 		variant.javaCompile.classpath,
		// 		file("${project.buildDir}/intermediates/classes/${output.dirName}")).asType(List)
		// options.doclet = "ydoc.doclets.YStandard"
		// options.addStringOption("resourcepath", binFile("${COMMON_TOOLS}/javaDoc/yworks-doclet/resources").absolutePath)
		// options.addStringOption("filterpath", binFile("${COMMON_TOOLS}/javaDoc/yworks-doclet/lib/ydoc.jar").absolutePath)
		// options.addStringOption("filter", "ydoc.filters.ExcludeFilter")
		// options.addStringOption("tag", "y.exclude")
        // options.optionFiles << optionsFile
        // options.memberLevel = javadocMemberLevel

        options.optionFiles << optionsFile
        options.memberLevel = javadocMemberLevel
    }

    def javaDocSource = "${project.buildDir}/javadoc/${archiveName}"

    // Adds syntax highlighting to Java source code samples in the generated JavaDoc.
    def syntaxTheme = "Eclipse"
    def syntaxifiedFiles = "${project.buildDir}/javadoc.syntaxified/${archiveName}"
    def styleSheetFile = new File("${javaDocSource}/stylesheet.css")

    project.task("rmtSyntaxify00${varName}", type: Copy) {
        dependsOn project.tasks["rmtJavaDoc${varName}"]
        mustRunAfter project.tasks["rmtJavaDoc${varName}"]
        
        outputs.upToDateWhen {false}

        from "${project.rootProject.rootDir}/javaDoc/syntax-highlighter"
        into javaDocSource
    }

    project.task("rmtSyntaxify01${varName}", type: Copy) {
        dependsOn project.tasks["rmtSyntaxify00${varName}"]
        mustRunAfter project.tasks["rmtSyntaxify00${varName}"]
        
        outputs.upToDateWhen {false}

        from javaDocSource
        into syntaxifiedFiles
        include "**/*.html"

        filter { String line ->
            line.replaceAll("<(link.+\\s)(href=\")(.+)(/stylesheet\\.css\".+)>",
                    "<\$1\$2\$3\$4>\r\n<script type=\"text/javascript\" src=\"\$3/js/shCore.js\"></script>\r\n<script type=\"text/javascript\" src=\"\$3/js/shBrushJava.js\"></script>").
                    replaceAll("</html>",
                            "<script type=\"text/javascript\">SyntaxHighlighter.all()</script>\r\n</html>")
        }
    }

    project.task("rmtSyntaxify02${varName}", type: Copy) {
        dependsOn project.tasks["rmtSyntaxify01${varName}"]
        mustRunAfter project.tasks["rmtSyntaxify01${varName}"]
        
        outputs.upToDateWhen {false}

        from syntaxifiedFiles
        into javaDocSource
        include "**/*.html"

        if(styleSheetFile.exists()) {
            println "Stylesheet: ${styleSheetFile}"

            def styleSheet = styleSheetFile.getText("UTF-8")
            styleSheetFile.write("@import url(\"css/shCore.css\");\r\n" +
                    "@import url(\"css/shTheme${syntaxTheme}.css\");\r\n\r\n${styleSheet}")
        }
    }

    // Zips the generated JavaDoc and copies the zip file into the specified folder under the root
    // "build" directory
    def arcPath

    project.task("rmtArchiveJavaDoc00${varName}", type: Zip) {
        dependsOn project.tasks["rmtSyntaxify02${varName}"]
        mustRunAfter project.tasks["rmtSyntaxify02${varName}"]
        
        outputs.upToDateWhen {false}

        baseName archiveName
        from javaDocSource
        into "api"

        arcPath = archivePath
    }

    project.task("rmtArchiveJavaDoc${varName}", type: Copy) {
		group "RMT"
		
        dependsOn project.tasks["rmtArchiveJavaDoc00${varName}"]
        mustRunAfter project.tasks["rmtArchiveJavaDoc00${varName}"]
        
        outputs.upToDateWhen {false}

        from arcPath
        into "${outputPath}"

        println "Original archive path: ${arcPath}"
        println "Destination: ${outputPath}"
    }

    project.tasks["assemble${varName}"].dependsOn project.tasks["rmtArchiveJavaDoc${varName}"]
    
    //project.tasks.matching { task ->
    //    task.name.startsWith('rmt')
    //}*.group = 'RMT'
}

ext.createJavaDocWithExclude = { /* ConfigurableFileCollection */ additionalSourceFiles, /* ConfigurableFileCollection */ additionalClasspathFiles,
                      /* List */ excludedFiles,
                      /* Project */ project, /* BaseVariant */ variant, /* BaseVariantOutput */ output,
                      /* String */ javaDocTitle, /* JavadocMemberLevel */ javadocMemberLevel, /* String */ archiveName,
                      /* String */ outputPath, /* BaseExtension */ android ->
    def platformDir = getSdkPlatformFolder(android.sdkDirectory, android.compileSdkVersion)
    def varName = variant.name.capitalize()

    println "android.sdkDirectory type: " + android.sdkDirectory.class
    println "android.compileSdkVersion type: " + android.compileSdkVersion.class

    // Modifies the generated R.java and Manifest.java to add "@y.exclude" yDoc JavaDoc tags to
    // exclude them from the JavaDoc
    def resSource = "${project.buildDir}/generated/source/r/${output.dirName}"
    def resExcluded = "${project.buildDir}/r.excluded/source/r/${output.dirName}"

    project.task("rmtExcludeRes00${varName}", type: Copy) {
        dependsOn project.tasks["compile${varName}Sources"]
        mustRunAfter project.tasks["compile${varName}Sources"]
    
        outputs.upToDateWhen {false}

        from resSource
        into resExcluded
        include "**/Manifest.java"
        include "**/R.java"

        filter { String line ->
            line.replaceAll("/\\*.*?\\*/", "/* */").
                    replaceAll("(public)(\\s+)(\\S*)(\\s*)(final)(\\s+)",
                            "/** @y.exclude */ \$1\$2\$3\$4\$5\$6")
        }
    }

    project.task("rmtExcludeRes${varName}", type: Copy) {
        dependsOn project.tasks["rmtExcludeRes00${varName}"]
        mustRunAfter project.tasks["rmtExcludeRes00${varName}"]
    
        outputs.upToDateWhen {false}

        from resExcluded
        into resSource
        include "**/Manifest.java"
        include "**/R.java"
    }

    // Generates the JavaDoc with UML using yDoc doclet
    project.task("rmtJavaDoc${varName}", type: Javadoc) {
	    // if (Os.isFamily(Os.FAMILY_WINDOWS)) {
		// 	def osBit = System.properties['sun.arch.data.model']
		// 	executable = "$COMMON_TOOLS/javaDoc/jdk/win/${osBit}-bit/bin/javadoc.exe"
		// 	println "OS: Windows ${osBit}-bit"
		// 	println "Using bundled javadoc.exe (JDK 7u80)..."
		// 	println "   \"$executable\""
		// }
		
        dependsOn project.tasks["rmtExcludeRes${varName}"]
        mustRunAfter project.tasks["rmtExcludeRes${varName}"]
		
		if (excludedFiles != null) {
		    exclude(excludedFiles)
		}
        
        title = javaDocTitle
        source = variant.javaCompile.source

        if(javadocMemberLevel == null) {
            javadocMemberLevel = JavadocMemberLevel.PROTECTED
        }

        if(additionalSourceFiles != null) {
            source += additionalSourceFiles
        }

        ext.androidJar = "${platformDir}/android.jar"
        ext.androidAnnotJar = "${android.sdkDirectory}/tools/support/annotations.jar"

        classpath = files(variant.javaCompile.classpath.files,
                ext.androidJar,
                ext.androidAnnotJar)

        if(additionalClasspathFiles != null) {
            classpath += additionalClasspathFiles
        }

        options {
            linksOffline("http://d.android.com/reference", "${android.sdkDirectory}/docs/reference")
        }

        destinationDir = new File("${project.buildDir}/javadoc/${archiveName}")
        
        File optionsFile = file("${project.rootProject.rootDir}/javadoc.options")
        
		if(!optionsFile.exists()) {
			println "Using default JavaDoc options..."
			// optionsFile = binFile("${COMMON_TOOLS}/javaDoc/javadoc_default.options") // file("${COMMON_TOOLS}/javaDoc/javadoc_default.options")
            optionsFile = binFile("${COMMON_TOOLS}/javaDoc/javadoc_default_noydoc.options") // file("${COMMON_TOOLS}/javaDoc/javadoc_default.options")
		}
		
		// options.docletpath = files(configurations.yDoclet.files,
		// 		variant.javaCompile.classpath,
		// 		file("${project.buildDir}/intermediates/classes/${output.dirName}")).asType(List)
		// options.doclet = "ydoc.doclets.YStandard"
		// options.addStringOption("resourcepath", binFile("${COMMON_TOOLS}/javaDoc/yworks-doclet/resources").absolutePath)
		// options.addStringOption("filterpath", binFile("${COMMON_TOOLS}/javaDoc/yworks-doclet/lib/ydoc.jar").absolutePath)
		// options.addStringOption("filter", "ydoc.filters.ExcludeFilter")
		// options.addStringOption("tag", "y.exclude")
        // options.optionFiles << optionsFile
        // options.memberLevel = javadocMemberLevel
		
        options.optionFiles << optionsFile
        options.memberLevel = javadocMemberLevel
    }

    def javaDocSource = "${project.buildDir}/javadoc/${archiveName}"

    // Adds syntax highlighting to Java source code samples in the generated JavaDoc.
    def syntaxTheme = "Eclipse"
    def syntaxifiedFiles = "${project.buildDir}/javadoc.syntaxified/${archiveName}"
    def styleSheetFile = new File("${javaDocSource}/stylesheet.css")

    project.task("rmtSyntaxify00${varName}", type: Copy) {
        dependsOn project.tasks["rmtJavaDoc${varName}"]
        mustRunAfter project.tasks["rmtJavaDoc${varName}"]
        
        outputs.upToDateWhen {false}

        from "${project.rootProject.rootDir}/javaDoc/syntax-highlighter"
        into javaDocSource
    }

    project.task("rmtSyntaxify01${varName}", type: Copy) {
        dependsOn project.tasks["rmtSyntaxify00${varName}"]
        mustRunAfter project.tasks["rmtSyntaxify00${varName}"]
        
        outputs.upToDateWhen {false}

        from javaDocSource
        into syntaxifiedFiles
        include "**/*.html"

        filter { String line ->
            line.replaceAll("<(link.+\\s)(href=\")(.+)(/stylesheet\\.css\".+)>",
                    "<\$1\$2\$3\$4>\r\n<script type=\"text/javascript\" src=\"\$3/js/shCore.js\"></script>\r\n<script type=\"text/javascript\" src=\"\$3/js/shBrushJava.js\"></script>").
                    replaceAll("</html>",
                            "<script type=\"text/javascript\">SyntaxHighlighter.all()</script>\r\n</html>")
        }
    }

    project.task("rmtSyntaxify02${varName}", type: Copy) {
        dependsOn project.tasks["rmtSyntaxify01${varName}"]
        mustRunAfter project.tasks["rmtSyntaxify01${varName}"]
        
        outputs.upToDateWhen {false}

        from syntaxifiedFiles
        into javaDocSource
        include "**/*.html"

        if(styleSheetFile.exists()) {
            println "Stylesheet: ${styleSheetFile}"

            def styleSheet = styleSheetFile.getText("UTF-8")
            styleSheetFile.write("@import url(\"css/shCore.css\");\r\n" +
                    "@import url(\"css/shTheme${syntaxTheme}.css\");\r\n\r\n${styleSheet}")
        }
    }

    // Zips the generated JavaDoc and copies the zip file into the specified folder under the root
    // "build" directory
    def arcPath

    project.task("rmtArchiveJavaDoc00${varName}", type: Zip) {
        dependsOn project.tasks["rmtSyntaxify02${varName}"]
        mustRunAfter project.tasks["rmtSyntaxify02${varName}"]
        
        outputs.upToDateWhen {false}

        baseName archiveName
        from javaDocSource
        into "api"

        arcPath = archivePath
    }

    project.task("rmtArchiveJavaDoc${varName}", type: Copy) {
		group "RMT"
		
        dependsOn project.tasks["rmtArchiveJavaDoc00${varName}"]
        mustRunAfter project.tasks["rmtArchiveJavaDoc00${varName}"]
        
        outputs.upToDateWhen {false}

        from arcPath
        into "${outputPath}"

        println "Original archive path: ${arcPath}"
        println "Destination: ${outputPath}"
    }

    project.tasks["assemble${varName}"].dependsOn project.tasks["rmtArchiveJavaDoc${varName}"]
    
    //project.tasks.matching { task ->
    //    task.name.startsWith('rmt')
    //}*.group = 'RMT'
}

/**
 *
 * @param project The project/module that is being processed.
 * @param variant The variant in the module that is being processed.
 * @param output The build variant in the module that is being processed.
 * @param outputDir The path to where the step counter file will be saved.
 * @param outputFile The name of the step counter file to be saved.
 */
ext.calculateLinesOfCode = { /* Project */ project, /* BaseVariant */ variant, /* BaseVariantOutput */ output, /* String */ outputDir, /* String */ outputFile ->
    println("+calculateLinesOfCode(\n" +
            "\tproject: [${project}],\n" +
            "\tvariant: [${variant}],\n" +
            "\toutput: [${output}])")

    def varName = variant.name.capitalize()

    println "\tproject.name: ${project.name}"
    println "\tproject.buildDir: ${project.buildDir}"
    println "\toutput.dirName: ${output.dirName}"
    println "\tvariant.sourceSets: ${variant.sourceSets}"

    def srcSet = files()

    // START: Retrieve all source files of the particular variant
    variant.sourceSets.each { src ->
        src.java.srcDirs.each { jSrc ->
            println "\t\tjava: ${jSrc.absolutePath}"

            if (jSrc.parentFile.exists() &&
                    (jSrc.absolutePath.endsWith("\\java") ||
                            jSrc.absolutePath.endsWith("/java"))) {
                println "\t\tadding java: ${jSrc.parentFile.absolutePath}"
                srcSet = srcSet + files(jSrc.parentFile)
            }
        }
    }
    // END: Retrieve all source files of the particular variant

    // START: Retrieve all generated source files of the particular variant
    File genFile = new File("${project.buildDir}/generated/source/aidl/${output.dirName}")

    if (genFile.exists()) {
        println "\t\tadding aidl: ${genFile.absolutePath}"
        srcSet = srcSet + files(genFile)
    }

    genFile = new File("${project.buildDir}/generated/source/buildConfig/${output.dirName}")

    if (genFile.exists()) {
        println "\t\tadding buildConfig: ${genFile.absolutePath}"
        srcSet = srcSet + files(genFile)
    }

    genFile = new File("${project.buildDir}/generated/source/r/${output.dirName}")

    if (genFile.exists()) {
        println "\t\tadding r and manifest: ${genFile.absolutePath}"
        srcSet = srcSet + files(genFile)
    }
    // END: Retrieve all generated source files of the particular variant

    srcSet.each { file ->
        println "\tfile: ${file.absolutePath}"
    }

    project.task("rmtStepCounter01${varName}DeleteFiles", type: Delete) {
        dependsOn project.tasks["compile${varName}Sources"]
        mustRunAfter project.tasks["compile${varName}Sources"]
        
        outputs.upToDateWhen {false}

        File tempFile = new File("${project.buildDir}/stepCounter/${output.dirName}")

        doLast {
            println "deleting ${tempFile.absolutePath}"
        }

        if(tempFile.exists()) {
            delete tempFile
        }
    }

    // Copy all Java and XML source files (including generated files) into a temporary folder.
    // Exclude any files from android.support.* package.
    // Exclude any package-info.java file.
    // Exclude any AndroidManifest.xml file.
    project.task("rmtStepCounter02${varName}CopyFiles") {
        dependsOn project.tasks["rmtStepCounter01${varName}DeleteFiles"]
        mustRunAfter project.tasks["rmtStepCounter01${varName}DeleteFiles"]
        
        outputs.upToDateWhen {false}

        doLast {
            srcSet.each { file ->
                copy {
                    from file
                    into "${project.buildDir}/stepCounter/${output.dirName}/${file.name}"
                    include "**/*.java"
                    include "**/*.xml"
                    exclude "**/android/support/**"
                    exclude "**/*.aidl"
                    exclude "**/package-info.java"
                    exclude "**/AndroidManifest.xml"
                }
            }
        }
    }

    // Copy the aggregated AndroidManifest.xml file into the temporary folder.
    project.task("rmtStepCounter03${varName}CopyManifest", type: Copy) {
        dependsOn project.tasks["rmtStepCounter02${varName}CopyFiles"]
        mustRunAfter project.tasks["rmtStepCounter02${varName}CopyFiles"]
        
        outputs.upToDateWhen {false}

        from "${project.buildDir}/intermediates/manifests/full/${output.dirName}/AndroidManifest.xml"
        into "${project.buildDir}/stepCounter/${output.dirName}"
    }

    // Call Amateras StepCounter to generate the CSV file containing the line count based on the
    // files from the temporary folder.
    // java -cp stepcounter.jar tk.stepcounter.Main -format=csv -output="${project.buildDir}/stepCounter/${output.dirName}" -encoding=UTF-8 "${project.buildDir}/stepCounter/${output.dirName}"
    project.task("rmtStepCounter04${varName}ExecSC", type: JavaExec) {
        dependsOn project.tasks["rmtStepCounter03${varName}CopyManifest"]
        mustRunAfter project.tasks["rmtStepCounter03${varName}CopyManifest"]
        
        outputs.upToDateWhen {false}

        //File outputScFile = new File("${project.rootProject.rootDir}/stepCounter/${buildType}")
        File outputScFile = new File(outputDir)
        outputScFile.mkdirs()

        //outputScFile = new File(outputScFile, "${outFileUnsigned}.csv")
        outputScFile = new File(outputScFile, outputFile)

        classpath = files(binFile("${COMMON_TOOLS}/stepCounter/stepcounter.jar"))
        main = "tk.stepcounter.Main"
        args = [
                "-format=csv",
                "-output=\"${outputScFile.absolutePath}\"",
                "-encoding=UTF-8",
                "\"${project.buildDir}/stepCounter/${output.dirName}\""
        ]

        // The generated CSV does not contain any header and/or summary of the line count.  So,
        // we have to add them ourselves.
        doLast {
            String csvContent = outputScFile.getText("UTF-8")
            csvContent = csvContent.replace("\r\n", "\n")       // Normalize.  Some lines may end with Windows-style separator (\r\n); some may end with *nix-style (\n).  Make them uniform.
            csvContent = csvContent.replace("\n", "\r\n")       // Ensure that all lines end with Windows-style separator.
            int lines = csvContent.split("\n").length + 1;
            outputScFile.withWriter("UTF-8") { writer ->                    // Seems to write in "UTF-8 without BOM"
                writer.write("\ufeff" +                                     // Force BOM header to display Japanese chars correctly in Excel
                        "\"\u30d5\u30a1\u30a4\u30eb\r\n(File)\"," +         // Header: ファイル (File)
                        "\"\u7a2e\u985e\r\n(Type)\"," +                     // Header: 種類 (Type)
                        "\"\u30ab\u30c6\u30b4\u30ea\r\n(Category)\"," +     // Header: カテゴリ (Category)
                        "\"\u5b9f\u884c\r\n(Executable)\"," +               // Header: 実行 (Run)
                        "\"\u7a7a\u884c\r\n(Blank Lines)\"," +              // Header: 空行 (Blank Lines)
                        "\"\u30b3\u30e1\u30f3\u30c8\r\n(Comment)\"," +      // Header: コメント (Comment)
                        "\"\u5408\u8a08\r\n(Total)\"\r\n" +                 // Header: 合計 (Total)
                        "${csvContent}\r\n" +                               // Step Count Data (starts from row 2)
                        ",,\u5408\u8a08 (Total),=sum(D2:D${lines}),=sum(E2:E${lines}),=sum(F2:F${lines}),=sum(G2:G${lines})")  // Summation
            }
        }
    }

    project.task("rmtGenerateStepCounter${varName}") {
		group "RMT"
		
        dependsOn project.tasks["rmtStepCounter04${varName}ExecSC"]
        mustRunAfter project.tasks["rmtStepCounter04${varName}ExecSC"]
	}
        
    project.tasks["assemble${varName}"].dependsOn project.tasks["rmtGenerateStepCounter${varName}"]
    
    //project.tasks.matching { task ->
    //    task.name.startsWith('rmt')
    //}*.group = 'RMT'

    println("-calculateLinesOfCode")
}

/**
 * The built-in signingConfigs of the Android Gradle plugin only allows us
 * to sign our APK(s) once.
 *
 * The set of tasks below will allow us to sign our APK(s) multiple times
 * with different keys.
 *
 * To configure a project to use this signing method (instead of the built-in
 * one), we must define an extension in the target project named "jarSignerConfig".
 * This extension must be defined as a Map<String, Map<String, String>> where each
 * key in the map is a unique name of our signing config (must follow the variable
 * naming rules) and each value is another Map containing the settings of the
 * signing config, such as the keystore path, the key alias to be used, an the
 * store and key passwords.
 * 
 * Optionally, we can also add a boolean with the key "signNonDebugBuild" which will
 * determine whether or not non-debuggable build types (i.e. buildTypes with
 * "debuggable false") should also be signed.  By convention, non-debuggable types
 * are the release versions which are normally not signed by the build tool.
 * This value is false by default.
 *
 * Example:
 * ext {
 *     jarSignerConfig = [
 *         signNonDebugBuild: true,
 *         config1: [
 *             keystore: "path/to/my/keystore.ks",
 *             storePass: "keystorepassword",
 *             keyPass: "keypassword",
 *             alias: "keyalias"
 *         ],
 *         config2: [
 *             keystore: "path/to/my/second/keystore2.ks",
 *             storePass: "myPasswordIsAwesome",
 *             keyPass: "anotherAwesomePassword",
 *             alias: "anAwesomeAlias"
 *         ]
 *     ]
 * }
 *
 * The sample configuration above will cause all your debuggable and non-debuggable APK(s)
 * to be signed 2x with the keys defined in config1 and config2.
 *
 * Please note that using this signing method will overwrite any signature created
 * by the built-in signingConfigs.
 */
afterEvaluate {
    if(project.hasProperty("jarSignerConfig")) {
        def signingTaskCount = 0
        def zipAlignExec = new File(new File(android.sdkDirectory, "build-tools/$android.buildToolsVersion"), "zipalign").absolutePath
        println("zipalign executable: $zipAlignExec")

        // Library projects do not have applicationVariants.
        // They have libraryVariants, which, we don't need to sign.
        if(project.android.hasProperty("applicationVariants")) {
            project.android.applicationVariants.all { variant ->
                def variantName = variant.name.capitalize()
                def returnVal = createSignApkTasks(project, variant, project.jarSignerConfig)
                String[] signingTasks = returnVal["signingTasks"]

                if(signingTasks.length > 0) {
                    Map<String, File> outputFiles = returnVal["outputFiles"]

                    project.task("rmtSignApk$variantName") {
                        group "rmt signer"
                        dependsOn signingTasks
                    }

                    signingTaskCount += signingTasks.length

                    if(variant.buildType.zipAlignEnabled) {
                        project.task("rmtZipAlign$variantName", type: Exec) {
                            dependsOn project.tasks["rmtSignApk$variantName"]

                            commandLine "\"$zipAlignExec\"", "-v",
                                    "-f", "4",
                                    "\"" + outputFiles["signedApk"].absolutePath + "\"",
                                    "\"" + outputFiles["alignedApk"].absolutePath + "\""
                        }

                        project.tasks["assemble$variantName"].dependsOn project.tasks["rmtZipAlign$variantName"]
                    } else {
                        project.tasks["assemble$variantName"].dependsOn project.tasks["rmtSignApk$variantName"]
                    }
                }
            }
        }

        // testVariants is present to both application and library projects
        project.android.testVariants.all { variant ->
            def variantName = variant.name.capitalize()
            def returnVal = createSignApkTasks(project, variant, project.jarSignerConfig)
            String[] signingTasks = returnVal["signingTasks"]

            if(signingTasks.length > 0) {
                Map<String, File> outputFiles = returnVal["outputFiles"]

                project.task("rmtSignApk$variantName") {
                    group "rmt signer"
                    dependsOn signingTasks
                }

                signingTaskCount += signingTasks.length

                if(variant.buildType.zipAlignEnabled) {
                    project.task("rmtZipAlign$variantName", type: Exec) {
                        dependsOn project.tasks["rmtSignApk$variantName"]

                        commandLine "\"$zipAlignExec\"", "-v",
                                "-f", "4",
                                "\"" + outputFiles["signedApk"].absolutePath + "\"",
                                "\"" + outputFiles["alignedApk"].absolutePath + "\""
                    }

                    project.tasks["assemble$variantName"].dependsOn project.tasks["rmtZipAlign$variantName"]
                } else {
                    project.tasks["assemble$variantName"].dependsOn project.tasks["rmtSignApk$variantName"]
                }
            }
        }

        if(signingTaskCount > 0) {
			println("")
            println("IMPORTANT NOTICE: Custom signing configurations (jarSignerConfig) were found for this project!")
            println("                  Any signature done by the built-in signer will be discarded and replaced with")
            println("                  those defined by jarSignerConfig.")
			println("")
        }
    }
}

/**
 * <p>
 * Retrieves the correct platform path (${sdkDirectory}/platforms/${platformDir}) that corresponds
 * to the given SDK/API version.
 *
 * @param sdkDirectory The root Android SDK path from where to search for the platform.
 * @param compileSdkVersion The SDK version to check (format: "android-${apiLevel}";
 *                          ex: "android-21" for Android Lollipop 5.0).
 * @return The platform path corresponding to the given SDK version.
 */
File getSdkPlatformFolder(File sdkDirectory, String compileSdkVersion) {
    def platformDir

    // Retrieve the list of folders, in SDK/platforms.
    def platformsDir = new File(sdkDirectory, "platforms")

    def platforms = platformsDir.listFiles()
    def numPlatforms = platforms.length

    def platformIndex = 0

    // Iterate through all the platforms subfolders
    for(; platformIndex < numPlatforms; platformIndex++) {
        platformDir = platforms[platformIndex]
        def propFile = new File(platformDir, "source.properties")

        println("Prop file: ${propFile}")

        // Check if ${sdkDirectory}/platforms/${platformDir}/source.properties exists
        if(propFile.exists() && propFile.isFile()) {
            def apiLevel = ""

            // If it exists, retrieve the value of the property, "AndroidVersion.ApiLevel"
            file(propFile).withReader { reader ->
                def sdkProps = new Properties()
                sdkProps.load(reader)
                apiLevel = sdkProps.getProperty("AndroidVersion.ApiLevel")
            }

            println("API level: ${apiLevel}")

            // If the value of "AndroidVersion.ApiLevel" matches the given version, then we've
            // found the platform folder.
            if("android-${apiLevel}".equalsIgnoreCase(compileSdkVersion.toString())) {
                break;
            }
        }
    }

    return platformDir
}

/**
 * Creates several tasks for signing an APK using the custom jarSignerConfig configuration.
 *
 * Returns a Map<String, Object> containing the following (key: value):
 *   signingTasks: String[] containing the names of the tasks that will perform the signing of the APK.
 *   outputFiles: Map<String, File> containing the output files where:
 *      unsignedApk: The file pointing to the unsigned APK
 *      signedApk: The file pointing to the signed (unaligned) APK
 *      alignedApk: The file pointing to the signed and aligned APK
 */
def createSignApkTasks(project, variant, jarSignerConfig) {
    def variantDebuggable = variant.buildType.debuggable
    def signNonDebugBuild = (jarSignerConfig["signNonDebugBuild"] == null) ? false : jarSignerConfig["signNonDebugBuild"]
    def configCount = jarSignerConfig.size() - (jarSignerConfig.containsKey("signNonDebugBuild") ? 1 : 0)

    def signingTasks = [];
    def outputFiles = new HashMap<>()

    // If the buildType is non-debuggable and jarSignerConfig is
    // not set to sign non-debug builds, then we don't create
    // any signing task for that build.

    if(variantDebuggable || signNonDebugBuild) {
        def variantName = variant.name.capitalize()

        def unsignedApk
        def signedApk
        def alignedApk

        variant.outputs.each { output ->
			def baseFile = file(output.outputFile.absolutePath.replace("-unsigned.apk", ".apk"))
			baseFile = file(baseFile.absolutePath.replace("-unaligned.apk", ".apk"))
			baseFile = file(baseFile.absolutePath.replace("-signed.apk", ".apk"))
			
			output.outputFile = baseFile
			output.packageApplication.outputFile = file(baseFile.absolutePath.replace(".apk", "-unaligned.apk"))
		
			// The Android Gradle plugin uses the same file for the original input (unsigned APK)
			// and the final output (aligned APK)
            unsignedApk = output.outputFile
            signedApk = output.packageApplication.outputFile
            alignedApk = output.outputFile

            // Since this is actually a signed APK, remove the "-unsigned" suffix
            // and replace it with "-unaligned" which is currently the suffix used
            // by the Android Gradle plugin to mark an APK as signed (but not yet
            // aligned).
            // TODO: Please note that this may change in the future!
            if(signedApk.name.endsWith("-unsigned.apk")) {
                signedApk = file(signedApk.absolutePath.replace("-unsigned.apk", "-unaligned.apk"))
            }

            if(alignedApk.name.endsWith("-unsigned.apk")) {
                alignedApk = file(alignedApk.absolutePath.replace("-unsigned.apk", ".apk"))
            }
			
            if(alignedApk.name.endsWith("-unaligned.apk")) {
                alignedApk = file(alignedApk.absolutePath.replace("-unaligned.apk", ".apk"))
            }
			
            if(unsignedApk.name.endsWith("-unaligned.apk")) {
                unsignedApk = file(unsignedApk.absolutePath.replace("-unaligned.apk", ".apk"))
            }
			
			println("")
			println("Variant: $variantName")
			println("    unsignedApk: $unsignedApk")
			println("    signedApk: $signedApk")
			println("    alignedApk: $alignedApk")

            outputFiles = [
                    unsignedApk: unsignedApk,
                    signedApk: signedApk,
                    alignedApk: alignedApk
            ]

            // (1)
            // Copy the original signed APK into a temporary folder
            // (in "build\distributions"), removing the "META-INF"
            // inside the APK.
            // Removing the "META-INF" from the original APK is
            // necessary as it seems to prevent us from properly
            // re-signing the APK with JarSigner.
            def dependsOnTask
            def mustRunAfterTask

            if(output.zipAlign) {
                dependsOnTask = project.tasks["zipalign$variantName"]
                mustRunAfterTask = project.tasks["zipalign$variantName"]
            } else {
                dependsOnTask = project.tasks["package$variantName"]
                mustRunAfterTask = project.tasks["package$variantName"]
            }
			
			if(variantDebuggable) {
				project.task("rmtUnsignApk$variantName", type: Zip) {
					dependsOn dependsOnTask
					mustRunAfter mustRunAfterTask

					archiveName "$project.name${variantName}.apk"

					// The aligned APK may have the same name as the unsigned APK.
					// This is because the built-in tasks which perform the
					// signing overwrites the unsigned APK with the aligned
					// APK.  And since our tasks runs after the built-in
					// tasks, what we're referring to as the unsigned APK
					// may have already been signed and aligned by this time.
					from zipTree(signedApk)

					// If the input APK is indeed a signed APK, then,
					// remove the META-INF folder that contains the signature.
					exclude "META-INF/**"
				}
			} else {
				// If the variant is non-debuggable, it usually means it's a
				// release variant and so should not have a signed APK in the
				// first place.
				project.task("rmtUnsignApk$variantName", type: Zip) {
					dependsOn dependsOnTask
					mustRunAfter mustRunAfterTask

					archiveName "$project.name${variantName}.apk"

					// The aligned APK may have the same name as the unsigned APK.
					// This is because the built-in tasks which perform the
					// signing overwrites the unsigned APK with the aligned
					// APK.  And since our tasks runs after the built-in
					// tasks, what we're referring to as the unsigned APK
					// may have already been signed and aligned by this time.
					from zipTree(unsignedApk)

					// An unsigned APK should not have a META-INF folder, but
					// just to be sure, we still exclude it in case it's there.
					exclude "META-INF/**"
				}
			}

            // (2)
            // Delete the original unsigned, signed and aligned APKs from "build\outputs\apk".
            project.task("rmtDeleteSignedApk$variantName", type: Delete) {
                dependsOn project.tasks["rmtUnsignApk$variantName"]
                mustRunAfter project.tasks["rmtUnsignApk$variantName"]

                delete unsignedApk, signedApk, alignedApk
            }

            // (3)
            // Put the unsigned APK created in step (1) into "build\outputs\apk".
            project.task("rmtCopyUnsignedApk$variantName", type: Copy) {
                dependsOn project.tasks["rmtDeleteSignedApk$variantName"]
                mustRunAfter project.tasks["rmtDeleteSignedApk$variantName"]

                from "$project.buildDir/distributions/$project.name${variantName}.apk"
                into output.outputFile.parentFile

                rename file("$project.buildDir/distributions/$project.name${variantName}.apk").name,
                        unsignedApk.name
            }

            // (4)
            // Delete the temporary APK from the distributions folder
            project.task("rmtDeleteUnsingedApk$variantName", type: Delete) {
                dependsOn project.tasks["rmtCopyUnsignedApk$variantName"]
                mustRunAfter project.tasks["rmtCopyUnsignedApk$variantName"]

                delete file("$project.buildDir/distributions/$project.name${variantName}.apk")
            }

            // (5)
            // Create the input APK for JarSigner.
            // We will use signedApk as the input and output of JarSigner
            // so that we won't have to worry about input for multiple
            // JarSigner sessions.
            if(configCount > 0) {
                project.task("rmtCreateJarSignerInput$variantName", type: Copy) {
                    dependsOn project.tasks["rmtDeleteUnsingedApk$variantName"]
                    mustRunAfter project.tasks["rmtDeleteUnsingedApk$variantName"]

					doFirst {
						println("rmtCreateJarSignerInput$variantName> [src] unsignedApk: $unsignedApk")
						println("rmtCreateJarSignerInput$variantName> [dst] signedApk: $signedApk")
					}
					
                    from unsignedApk.absolutePath
                    into unsignedApk.parentFile

                    rename unsignedApk.name, signedApk.name

					doLast {
						println("rmtCreateJarSignerInput$variantName> [src] unsignedApk: $unsignedApk")
						println("rmtCreateJarSignerInput$variantName> [dst] signedApk: $signedApk")
					}
                }
            }
        }

        jarSignerConfig.each { config ->
            def configName = config.key.capitalize()

            if(!config.key.equals("signNonDebugBuild")) {
                // (6)
                // Sign the unsigned APK with the specified key using JarSigner.
                project.task("rmtSignApkWithJarSigner$configName$variantName", type: Exec) {
                    dependsOn project.tasks["rmtCreateJarSignerInput$variantName"]
                    mustRunAfter project.tasks["rmtCreateJarSignerInput$variantName"]

                    def keyStore = config.value["keystore"]
                    def storePass = config.value["storePass"]
                    def keyPass = config.value["keyPass"]
                    def alias = config.value["alias"]

                    doLast {
                        if(signedApk.exists()) {
                            println("Signed $signedApk.absolutePath")
                            println("    Keystore: $keyStore")
                            println("    Alias: $alias")
                        }
                    }

                    commandLine "jarsigner", "-verbose",
                            "-sigalg", "SHA1withRSA",
                            "-digestalg", "SHA1",
                            "-keystore", "\"$keyStore\"",
                            "-storepass", "\"$storePass\"",
                            "-keypass", "\"$keyPass\"",
                            "\"$signedApk.absolutePath\"",
                            "\"$alias\""
                }

                signingTasks << "rmtSignApkWithJarSigner$configName$variantName"
            }
        }
    }

    return [
            signingTasks: signingTasks,
            outputFiles: outputFiles
    ]
}

dependencies {
    yDoclet files(binFile("${COMMON_TOOLS}/javaDoc/yworks-doclet/lib/ydoc.jar"))
    yDoclet fileTree(binFile("${COMMON_TOOLS}/javaDoc/yworks-doclet/resources"))
}

// -------------------------------------------------------------------------------------------------
// END: CUSTOM SCRIPTS
// -------------------------------------------------------------------------------------------------
