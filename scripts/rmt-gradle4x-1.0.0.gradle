/**
 * Helper functions to help set up Gradle tasks for commonly used procedures.  To use this in your
 * AS projects, import this script into your module by adding:
 *     apply from: '<absolute_path_to_script>/rmt-<version>.gradle
 *
 * Example:
 *     apply from: 'scripts/rmt-1.0.0.gradle'
 *
 * This is specifically for Android Gradle Plugin v3.x and up
 
 * This will make the following functions available:
 *     + exportAar - Exports the AAR and extracts the JAR (inside the AAR) into the specified
 *                   location renaming the files to the specified name.
 *     + exportApk - TODO: To be implemented
 *     + exportProguardMapping - Copies the Proguard map files into a specified folder.
 *     + createJavaDoc - Generates JavaDoc w/ UML diagrams from the specified source files.
 *     + calculateLinesOfCode - Generates step count of the source code using Amateras StepCounter.
 * 
 * Original author    : Rex M. Torres
 * Creation date      : 07 March 2016
 */

ext.cdnRoot = "https://rexmtorres.github.io/Custom-Build-Scripts"
ext.binVersion = "v1"
ext.cacheRoot = "${System.getProperty("user.home")}/.gradle/rmtcache/${binVersion}"

def downloadBin() {
    def url = new URL("${cdnRoot}/bin_${binVersion}.zip")
    def localFile = new File("${cacheRoot}/bin.zip")
    def localRoot = localFile.parentFile

    if (!localRoot.exists()) {
        localRoot.mkdirs()
    }

    url.withInputStream { ins ->
        localFile.withOutputStream { ous -> ous << ins }
    }

    copy {
        from zipTree(localFile)
        into localRoot
    }
}

def binFile(location) {
    def localFile = new File(location)

    println "File => ${localFile}"

    if (localFile.exists()) {
        println "Local cache exists!  Reusing..."
        return localFile
    }

    println "Local cache does not exist!  Downloading..."
    downloadBin()

    return localFile
}

// -------------------------------------------------------------------------------------------------
// START: CUSTOM SCRIPTS
// -------------------------------------------------------------------------------------------------
import org.apache.tools.ant.taskdefs.condition.Os

def COMMON_TOOLS = "${cacheRoot}/bin"

configurations {
    yDoclet
}

ext.createDeliveryTasks = [
    "createAll": [],
    "createByBuildType": [:],
    "createByFlavor": [:]
]

def addTask(String taskName, String buildTypeName, String flavorName) {
    if (!createDeliveryTasks.createAll.contains(taskName)) {
        createDeliveryTasks.createAll << taskName
    }

    if ((buildTypeName != null) && !buildTypeName.isEmpty()) {
        if (createDeliveryTasks.createByBuildType[buildTypeName] == null) {
            createDeliveryTasks.createByBuildType[buildTypeName] = []
        }

        if (!createDeliveryTasks.createByBuildType[buildTypeName].contains(taskName)) {
            createDeliveryTasks.createByBuildType[buildTypeName] << taskName
        }
    }

    if ((flavorName != null) && !flavorName.isEmpty()) {
        if (createDeliveryTasks.createByFlavor[flavorName] == null) {
            createDeliveryTasks.createByFlavor[flavorName] = []
        }

        if (!createDeliveryTasks.createByFlavor[flavorName].contains(taskName)) {
            createDeliveryTasks.createByFlavor[flavorName] << taskName
        }
    }
}

// TODO: implement exportApk w/ unsign feature
//    // for library projects, use "compileXXXSources".  for apk projects, use "packageXXX"
//    //tasks["export{variantName.capitalize()}Aar"].mustRunAfter tasks["package${variantName.capitalize()}"]
ext.exportAar = {
        /* LibraryVariant */ variant,
        /* String */ destFolder,
        /* String */ baseFileName ->

    def fileExt = "aar"

    def flavorName = variant.flavorName
    def buildTypeName = variant.buildType.name
    def variantName = variant.name
    def variantPath = variant.dirName

    def fileName = "${variantPath}/${baseFileName}.${fileExt}"
    def buildFile = file("${project.buildDir}/outputs/${fileExt}/$fileName")

    println("flavorName: ${flavorName}")
    println("buildTypeName: ${buildTypeName}")
    println("variantName: ${variantName}")

    println("fileName: ${fileName}")
    println("buildFile: ${buildFile}")

    def exportTaskName = "rmtExport${variantName.capitalize()}${fileExt.capitalize()}"

    variant.outputs.all {
        println("outputFileName: ${outputFileName}")

        // This is the recommended way to rename APKs in gradle 3.0+ but,
        // this should only be used for renaming the APK file itself, not
        // moving it to another location outside the build folder.
        outputFileName = fileName
        println("outputFileName: ${outputFileName}")

        // We now need to create a task to move/copy the APK/AAR to a new location.
        task(exportTaskName) {
            dependsOn tasks["assemble${variantName.capitalize()}"]
			group "RMT"
			
            inputs.file(buildFile)
            outputs.file("${destFolder}/${baseFileName}.${fileExt}")
            outputs.upToDateWhen { false }

            doLast {
                copy {
                    from(buildFile)
                    into(destFolder)
                }

				copy {
					from zipTree(buildFile)
					into destFolder
					include "*.jar"
					rename "classes.jar", "${baseFileName}.jar"
				}
            }
        }
    }

    if (tasks.findByName("create${variantName.capitalize()}Delivery") == null) {
        task("create${variantName.capitalize()}Delivery") {
            group "rmtDelivery"
        }
    }

    tasks["create${variantName.capitalize()}Delivery"].dependsOn tasks[exportTaskName]

    addTask("create${variantName.capitalize()}Delivery", buildTypeName, flavorName)
}

ext.exportApk = {
        /* ApplicationVariant */ variant,
        /* String */ destFolder,
        /* String */ baseFileName,
        /* boolean */ unsignApk ->

    def fileExt = "apk"

    def flavorName = variant.flavorName
    def buildTypeName = variant.buildType.name
    def variantName = variant.name
    def variantPath = variant.dirName

    //def fileName = "${variantPath}/${baseFileName}.${fileExt}"
    def fileName = "${baseFileName}.${fileExt}"
    def buildFile = file("${project.buildDir}/outputs/${fileExt}/${variantPath}/$fileName")
    def unsignedFile = "${variantPath}/$fileName"

    println("flavorName: ${flavorName}")
    println("buildTypeName: ${buildTypeName}")
    println("variantName: ${variantName}")

    println("fileName: ${fileName}")
    println("buildFile: ${buildFile}")

    def exportTaskName = "rmtExport${unsignApk ? "Unsigned" : "Signed"}${variantName.capitalize()}${fileExt.capitalize()}"

    variant.outputs.all {
        println("outputFileName: ${outputFileName}")

        if (unsignApk) {
            task("rmtUnsignApk${variantName.capitalize()}", type: Zip) {
                dependsOn tasks["assemble${variantName.capitalize()}"]
                outputs.upToDateWhen { false }

                // under "${project.buildDir}/distributions" as per Gradle doc
                // (https://docs.gradle.org/current/userguide/working_with_files.html#sec:archive_naming)
                archiveName unsignedFile

                from zipTree(buildFile)

                // Remove the META-INF folder that contains the signature.
                exclude "META-INF/**"
            }
        }

        // This is the recommended way to rename APKs in gradle 3.0+ but,
        // this should only be used for renaming the APK file itself, not
        // moving it to another location outside the build folder.
        outputFileName = fileName
        println("outputFileName: ${outputFileName}")

        def inputApk = unsignApk ? file("${project.buildDir}/distributions/${unsignedFile}") : buildFile

        // We now need to create a task to move/copy the APK/AAR to a new location.
        task(exportTaskName) {
            if (unsignApk) {
                dependsOn tasks["rmtUnsignApk${variantName.capitalize()}"]
            } else {
                dependsOn tasks["assemble${variantName.capitalize()}"]
            }

			group "RMT"
			
            inputs.file(inputApk)
            outputs.file("${destFolder}/${baseFileName}.${fileExt}")
            outputs.upToDateWhen { false }

            doLast {
                copy {
                    from(inputApk)
                    into(destFolder)
                }
            }
        }
    }

    if (tasks.findByName("create${variantName.capitalize()}Delivery") == null) {
        task("create${variantName.capitalize()}Delivery") {
            group "rmtDelivery"
        }
    }

    tasks["create${variantName.capitalize()}Delivery"].dependsOn tasks[exportTaskName]

    addTask("create${variantName.capitalize()}Delivery", buildTypeName, flavorName)
}

/**
 * <p>
 * Creates an "exportMap${variant}" task, for the specified variant in the specified project/module,
 * which will be executed after the "proguard${variant}" task.
 *
 * <p>
 * The "exportMap${variant}" task will attempt to copy the Proguard map files, from the module's
 * "build" folder, into the "Proguard" folder under the root project.
 *
 * @param project The project/module that is being processed.
 * @param variant The variant in the module that is being processed.
 * @param outputFolder The name of the folder where the map files will be placed.
 */
ext.exportProguardMapping = { /* BaseVariant */ variant, /* String */ outputFolder ->
    // Copy the proguard map files to the root directory under "Proguard"
    String varName = variant.name.capitalize()
    def flavorName = variant.flavorName
    def buildTypeName = variant.buildType.name

    def srcDir = "${project.buildDir}/outputs/mapping/${variant.dirName}"

    println("source: ${srcDir}")
    println("destination: ${outputFolder}")

    task("rmtExportMap${varName}", type: Copy) {
        dependsOn tasks["assemble${varName}"]
		group "RMT"
		
		// if(tasks.findByPath("bundle${varName}") == null) {
		// 	println "Linking to task package${varName} instead..."
			
		// 	dependsOn tasks["package${varName}"]
		// 	mustRunAfter tasks["package${varName}"]
		// } else {
		// 	println "Linking to task bundle${varName} instead..."
			
		// 	dependsOn tasks["bundle${varName}"]
		// 	mustRunAfter tasks["bundle${varName}"]
		// }
    
        from(srcDir)
        into(outputFolder)
    }

    if (tasks.findByName("create${varName}Delivery") == null) {
        task("create${varName}Delivery") {
            group "rmtDelivery"
        }
    }

    tasks["create${varName}Delivery"].dependsOn tasks["rmtExportMap${varName}"]

    addTask("create${varName}Delivery", buildTypeName, flavorName)
}

/**
 * <p>
 * Generates the JavaDoc documentation of the specified variant of the specified project.
 *
 * <p>
 * Creates 4 tasks for the specified variant:
 * <ol>
 *     <li>rmtExcludeRes${variant} - Modifies R.java and Manifest.java to add "@y.exclude" yDoc
 *        JavaDoc tags to exclude them from the JavaDoc
 *     <li>rmtJavaDoc${variant} - Generates the JavaDoc with UML diagrams c/o the yDoc doclet
 *         (http://www.yworks.com/en/products_ydoc.html)
 *     <li>rmtSyntaxify${variant} - Beautifies source code samples in the JavaDoc by applying
 *         syntax highlighting using SyntaxHiglighter (http://alexgorbatchev.com/SyntaxHighlighter/)
 *     <li>rmtArchiveJavaDoc${variant} - Packages the generated JavaDoc into a ZIP file and puts
 *         the ZIP file into the root folder under "build/JavaDocs".
 * </ol>
 *
 * <p>
 * The 4 tasks are then executed in the order specified above.
 *
 * @param variant The variant in the module that is being processed.
 * @param additionalSourceFiles Additional source files, which
 *                              may not be part of the project, but are referenced by the project.
 *                              Examples would be source codes of external libraries used by the project.
 * @param additionalClasspathFiles Additional files to be included
 *                                 in the classpath.  The variant's classpath, as well as the
 *                                 Android classpath are already automatically added by this script
 *                                 so there's no need to include them in this classpath.  Only
 *                                 additional paths, like OMAPI, or any other external paths that the
 *                                 project may be using.
 * @param excludedFiles List of files to be excluded from the documentation
 * @param javaDocTitle The title of the JavaDoc
 * @param javadocMemberLevel Indicates the member visibility to be used
 *                           (JavadocMemberLevel.PUBLIC, JavadocMemberLevel.PACKAGE,
 *                           JavadocMemberLevel.PROTECTED, JavadocMemberLevel.PRIVATE)
 * @param archiveName The name of the ZIP file containing the JavaDoc to be generated.
 * @param outputPath The directory where the zipped JavaDoc will be placed.
 */
ext.createJavaDoc = { /* BaseVariant */ variant,
					  /* ConfigurableFileCollection */ additionalSourceFiles,
					  /* ConfigurableFileCollection */ additionalClasspathFiles,
                      /* List */ excludedFiles,
                      /* String */ javaDocTitle,
					  /* JavadocMemberLevel */ javadocMemberLevel,
					  /* String */ archiveName,
                      /* String */ outputPath ->
    def platformDir = getSdkPlatformFolder(android.sdkDirectory, android.compileSdkVersion)
    def varName = variant.name.capitalize()
    def flavorName = variant.flavorName
    def buildTypeName = variant.buildType.name

    println "android.sdkDirectory type: " + android.sdkDirectory
    println "android.compileSdkVersion type: " + android.compileSdkVersion
	
	variant.outputs.all { output ->
		// Modifies the generated R.java and Manifest.java to add "@y.exclude" yDoc JavaDoc tags to
		// exclude them from the JavaDoc
		def resSource = "${project.buildDir}/generated/source/r/${variant.name}"
		def resExcluded = "${project.buildDir}/r.excluded/source/r/${variant.name}"

		task("rmtExcludeRes00${varName}", type: Copy) {
			// dependsOn tasks["compile${varName}Sources"]
			// mustRunAfter tasks["compile${varName}Sources"]
            dependsOn tasks["assemble${varName}"]
		
			outputs.upToDateWhen {false}

			from resSource
			into resExcluded
			include "**/Manifest.java"
			include "**/R.java"

			filter { String line ->
				line.replaceAll("/\\*.*?\\*/", "/* */").
						replaceAll("(public)(\\s+)(\\S*)(\\s*)(final)(\\s+)",
								"/** @y.exclude */ \$1\$2\$3\$4\$5\$6")
			}
		}

		task("rmtExcludeRes${varName}", type: Copy) {
			dependsOn tasks["rmtExcludeRes00${varName}"]
			mustRunAfter tasks["rmtExcludeRes00${varName}"]
		
			outputs.upToDateWhen {false}

			from resExcluded
			into resSource
			include "**/Manifest.java"
			include "**/R.java"
		}

		// Generates the JavaDoc with UML using yDoc doclet
		task("rmtJavaDoc${varName}", type: Javadoc) {
			dependsOn tasks["rmtExcludeRes${varName}"]
			mustRunAfter tasks["rmtExcludeRes${varName}"]
			
            // if (Os.isFamily(Os.FAMILY_WINDOWS)) {
            //     def osBit = System.properties['sun.arch.data.model']
            //     executable = "$COMMON_TOOLS/javaDoc/jdk/win/${osBit}-bit/bin/javadoc.exe"
            //     println "OS: Windows ${osBit}-bit"
            //     println "Using bundled javadoc.exe (JDK 7u80)..."
            //     println "   \"$executable\""
            // }
            
            if (excludedFiles != null) {
                println "Excluding files: ${excludedFiles}"
                exclude(excludedFiles)
            }
            
            title = javaDocTitle
            source = variant.javaCompile.source

            if(javadocMemberLevel == null) {
                javadocMemberLevel = JavadocMemberLevel.PROTECTED
            }

            if(additionalSourceFiles != null) {
                println "Adding source files in: ${additionalSourceFiles}"
                additionalSourceFiles.each { sourceFile ->
                    println "\t${sourceFile.absolutePath}"
                }
                source += additionalSourceFiles
            }

            ext.androidJar = "${platformDir}/android.jar"
            ext.androidAnnotJar = "${android.sdkDirectory}/tools/support/annotations.jar"

            doFirst {
                classpath = files(variant.javaCompile.classpath.files,
                        ext.androidJar,
                        ext.androidAnnotJar)

                if(additionalClasspathFiles != null) {
                    println "Adding class files in: ${additionalClasspathFiles}"
                    additionalClasspathFiles.each { classFile ->
                        println "\t${classFile.absolutePath}"
                    }
                    classpath += additionalClasspathFiles
                }

                options {
                    linksOffline("http://d.android.com/reference", "${android.sdkDirectory}/docs/reference")
                }

                File optionsFile = file("${project.rootProject.rootDir}/javadoc.options")
                
                if(!optionsFile.exists()) {
                    println "Using default JavaDoc options..."
                    //optionsFile = binFile("${COMMON_TOOLS}/javaDoc/javadoc_default.options") // file("${COMMON_TOOLS}/javaDoc/javadoc_default.options")
                    optionsFile = binFile("${COMMON_TOOLS}/javaDoc/javadoc_default_noydoc.options") // file("${COMMON_TOOLS}/javaDoc/javadoc_default.options")
                }
                
                // options.docletpath = files(configurations.yDoclet.files,
                //         variant.javaCompile.classpath,
                //         file("${project.buildDir}/intermediates/classes/${variant.name}")).asType(List)
                // options.doclet = "ydoc.doclets.YStandard"
                // options.addStringOption("resourcepath", binFile("${COMMON_TOOLS}/javaDoc/yworks-doclet/resources").absolutePath)
                // options.addStringOption("filterpath", binFile("${COMMON_TOOLS}/javaDoc/yworks-doclet/lib/ydoc.jar").absolutePath)
                // options.addStringOption("filter", "ydoc.filters.ExcludeFilter")
                // options.addStringOption("tag", "y.exclude")
                // options.optionFiles << optionsFile
                // options.memberLevel = javadocMemberLevel
                
                options.optionFiles << optionsFile
                options.memberLevel = javadocMemberLevel
            }
		}

		def javaDocSource = tasks["rmtJavaDoc${varName}"].destinationDir // "${project.buildDir}/javadoc/${archiveName}"

		// Adds syntax highlighting to Java source code samples in the generated JavaDoc.
		def syntaxTheme = "Eclipse"
		def syntaxifiedFiles = "${project.buildDir}/javadoc.syntaxified/${archiveName}"
		def styleSheetFile = new File("${javaDocSource}/stylesheet.css")

		task("rmtSyntaxify00${varName}", type: Copy) {
			dependsOn tasks["rmtJavaDoc${varName}"]
			mustRunAfter tasks["rmtJavaDoc${varName}"]
			
			outputs.upToDateWhen {false}

			from binFile("${COMMON_TOOLS}/javaDoc/syntax-highlighter")
			into javaDocSource
		}

		task("rmtSyntaxify01${varName}", type: Copy) {
			dependsOn tasks["rmtSyntaxify00${varName}"]
			mustRunAfter tasks["rmtSyntaxify00${varName}"]
			
			outputs.upToDateWhen {false}

			from javaDocSource
			into syntaxifiedFiles
			include "**/*.html"

			filter { String line ->
				line.replaceAll("<(link.+\\s)(href=\")(.+)(/stylesheet\\.css\".+)>",
						"<\$1\$2\$3\$4>\r\n<script type=\"text/javascript\" src=\"\$3/js/shCore.js\"></script>\r\n<script type=\"text/javascript\" src=\"\$3/js/shBrushJava.js\"></script>").
						replaceAll("</html>",
								"<script type=\"text/javascript\">SyntaxHighlighter.all()</script>\r\n</html>")
			}
		}

		task("rmtSyntaxify02${varName}", type: Copy) {
			dependsOn tasks["rmtSyntaxify01${varName}"]
			mustRunAfter tasks["rmtSyntaxify01${varName}"]
			
			outputs.upToDateWhen {false}

			from syntaxifiedFiles
			into javaDocSource
			include "**/*.html"

			if(styleSheetFile.exists()) {
				println "Stylesheet: ${styleSheetFile}"

				def styleSheet = styleSheetFile.getText("UTF-8")
				styleSheetFile.write("@import url(\"css/shCore.css\");\r\n" +
						"@import url(\"css/shTheme${syntaxTheme}.css\");\r\n\r\n${styleSheet}")
			}
		}

		// Zips the generated JavaDoc and copies the zip file into the specified folder under the root
		// "build" directory
		def arcPath

		task("rmtArchiveJavaDoc00${varName}", type: Zip) {
			dependsOn tasks["rmtSyntaxify02${varName}"]
			mustRunAfter tasks["rmtSyntaxify02${varName}"]
			
			outputs.upToDateWhen {false}

			baseName archiveName
			from javaDocSource
			into "api"

			arcPath = archivePath
		}

		task("rmtArchiveJavaDoc${varName}", type: Copy) {
			group "RMT"
			
			dependsOn tasks["rmtArchiveJavaDoc00${varName}"]
			mustRunAfter tasks["rmtArchiveJavaDoc00${varName}"]
			
			outputs.upToDateWhen {false}

			from arcPath
			into "${outputPath}"

			println "Original archive path: ${arcPath}"
			println "Destination: ${outputPath}"
		}

        if (tasks.findByName("create${varName}Delivery") == null) {
            task("create${varName}Delivery") {
                group "rmtDelivery"
            }
        }

        tasks["create${varName}Delivery"].dependsOn tasks["rmtArchiveJavaDoc${varName}"]

        addTask("create${varName}Delivery", buildTypeName, flavorName)
	}
}

/**
 *
 * @param project The project/module that is being processed.
 * @param variant The variant in the module that is being processed.
 * @param output The build variant in the module that is being processed.
 * @param outputDir The path to where the step counter file will be saved.
 * @param outputFile The name of the step counter file to be saved.
 */
ext.calculateLinesOfCode = { /* BaseVariant */ variant,
                             /* String */ outputDir,
                             /* String */ outputFile ->
    println("+calculateLinesOfCode(\n" +
            "\tvariant: [${variant.name}],\n\toutputDir: [${outputDir}],\n\toutputFile: [${outputFile}],\n)")

    def varName = variant.name.capitalize()
    def flavorName = variant.flavorName
    def buildTypeName = variant.buildType.name
    def variantPath = variant.dirName

    variant.outputs.all { output ->
        println "\tproject.name: ${project.name}"
        println "\tproject.buildDir: ${project.buildDir}"
        println "\tvariant.name: ${variant.name}"
        println "\tvariant.sourceSets: ${variant.sourceSets}"

        def srcSet = files()

        // START: Retrieve all source files of the particular variant
        variant.sourceSets.each { src ->
            src.java.srcDirs.each { jSrc ->
                println "\t\tjava: ${jSrc.absolutePath}"

                if (jSrc.parentFile.exists() &&
                        (jSrc.absolutePath.endsWith("\\java") ||
                                jSrc.absolutePath.endsWith("/java"))) {
                    println "\t\t\tadding: ${jSrc.absolutePath}"
                    srcSet = srcSet + files(jSrc)
                }
            }

            src.res.srcDirs.each { jSrc ->
                println "\t\tres: ${jSrc.absolutePath}"

                if (jSrc.parentFile.exists() &&
                        (jSrc.absolutePath.endsWith("\\res") ||
                                jSrc.absolutePath.endsWith("/res"))) {
                    println "\t\t\tadding: ${jSrc.absolutePath}"
                    srcSet = srcSet + files(jSrc)
                }
            }
        }
        // END: Retrieve all source files of the particular variant

        // START: Retrieve all generated source files of the particular variant
        File genFile = new File("${project.buildDir}/generated/source/aidl/${variantPath}")

        println "\t\tadding aidl: ${genFile.absolutePath}"
        srcSet = srcSet + files(genFile)

        genFile = new File("${project.buildDir}/generated/source/buildConfig/${variantPath}")

        println "\t\tadding buildConfig: ${genFile.absolutePath}"
        srcSet = srcSet + files(genFile)

        genFile = new File("${project.buildDir}/generated/source/r/${variantPath}")

        println "\t\tadding r and manifest: ${genFile.absolutePath}"
        srcSet = srcSet + files(genFile)
        
        def stepCounterBuild = file("${project.buildDir}/stepCounter/${variantPath}")

        task("rmtStepCounter01${varName}DeleteFiles") {
            dependsOn tasks["assemble${varName}"]
            mustRunAfter tasks["assemble${varName}"]
            
            outputs.upToDateWhen { !stepCounterBuild.exists() }

            doLast {
                println "deleting ${stepCounterBuild.absolutePath}"
                delete stepCounterBuild
            }
        }

        // Copy all Java and XML source files (including generated files) into a temporary folder.
        // Exclude any files from android.support.* package.
        // Exclude any package-info.java file.
        // Exclude any AndroidManifest.xml file.
        task("rmtStepCounter02${varName}CopyFiles") {
            dependsOn tasks["rmtStepCounter01${varName}DeleteFiles"]
            mustRunAfter tasks["rmtStepCounter01${varName}DeleteFiles"]
            
            outputs.upToDateWhen {false}

            doLast {
                stepCounterBuild.mkdirs()

                srcSet.each { file ->
                    if (file.exists()) {
                        println "Copying ${file.absolutePath} into ${stepCounterBuild.absolutePath}/${file.name}..."

                        copy {
                            from file
                            into "${stepCounterBuild.absolutePath}/${file.name}"

                            include "**/*.java"
                            include "**/*.xml"

                            exclude "**/android/support/**/R.java"
                            exclude "**/android/arch/**/R.java"
                            exclude "**/*.aidl"
                            exclude "**/package-info.java"
                            exclude "**/AndroidManifest.xml"
                        }
                    }
                }
            }
        }

        // Copy the aggregated AndroidManifest.xml file into the temporary folder.
        task("rmtStepCounter03${varName}CopyManifest", type: Copy) {
            dependsOn tasks["rmtStepCounter02${varName}CopyFiles"]
            mustRunAfter tasks["rmtStepCounter02${varName}CopyFiles"]
            
            outputs.upToDateWhen {false}

            from "${project.buildDir}/intermediates/manifests/full/${variantPath}/AndroidManifest.xml"
            into "${stepCounterBuild.absolutePath}"
        }

        file(outputDir).mkdirs()

        def outputScFile = new File(outputDir, outputFile)

        // Call Amateras StepCounter to generate the CSV file containing the line count based on the
        // files from the temporary folder.
        // java -cp stepcounter.jar tk.stepcounter.Main -format=csv -output="${project.buildDir}/stepCounter/${variant.name}" -encoding=UTF-8 "${project.buildDir}/stepCounter/${variant.name}"
        task("rmtStepCounter04${varName}ExecSC", type: JavaExec) {
            dependsOn tasks["rmtStepCounter03${varName}CopyManifest"]
            mustRunAfter tasks["rmtStepCounter03${varName}CopyManifest"]
            
            outputs.upToDateWhen {false}

            classpath = files(binFile("${COMMON_TOOLS}/stepCounter/stepcounter.jar"))
            main = "tk.stepcounter.Main"
            args = [
                    "-format=csv",
                    "-output=\"${outputScFile.absolutePath}\"",
                    "-encoding=UTF-8",
                    "\"${stepCounterBuild.absolutePath}\""
            ]
        }

        task("rmtGenerateStepCounter${varName}") {
            group "RMT"
            
            dependsOn tasks["rmtStepCounter04${varName}ExecSC"]
            mustRunAfter tasks["rmtStepCounter04${varName}ExecSC"]

            // The generated CSV does not contain any header and/or summary of the line count.  So,
            // we have to add them ourselves.
            doLast {
                String csvContent = outputScFile.getText("UTF-8")
                csvContent = csvContent.replace("\r\n", "\n")       // Normalize.  Some lines may end with Windows-style separator (\r\n); some may end with *nix-style (\n).  Make them uniform.
                csvContent = csvContent.replace("\n", "\r\n")       // Ensure that all lines end with Windows-style separator.
                int lines = csvContent.split("\n").length + 1;
                outputScFile.withWriter("UTF-8") { writer ->                    // Seems to write in "UTF-8 without BOM"
                    writer.write("\ufeff" +                                     // Force BOM header to display Japanese chars correctly in Excel
                            "\"\u30d5\u30a1\u30a4\u30eb\r\n(File)\"," +         // Header: ファイル (File)
                            "\"\u7a2e\u985e\r\n(Type)\"," +                     // Header: 種類 (Type)
                            "\"\u30ab\u30c6\u30b4\u30ea\r\n(Category)\"," +     // Header: カテゴリ (Category)
                            "\"\u5b9f\u884c\r\n(Executable)\"," +               // Header: 実行 (Run)
                            "\"\u7a7a\u884c\r\n(Blank Lines)\"," +              // Header: 空行 (Blank Lines)
                            "\"\u30b3\u30e1\u30f3\u30c8\r\n(Comment)\"," +      // Header: コメント (Comment)
                            "\"\u5408\u8a08\r\n(Total)\"\r\n" +                 // Header: 合計 (Total)
                            "${csvContent}\r\n" +                               // Step Count Data (starts from row 2)
                            ",,\u5408\u8a08 (Total),=sum(D2:D${lines}),=sum(E2:E${lines}),=sum(F2:F${lines}),=sum(G2:G${lines})")  // Summation
                }
            }
        }
            
        if (tasks.findByName("create${varName}Delivery") == null) {
            task("create${varName}Delivery") {
                group "rmtDelivery"
            }
        }

        tasks["create${varName}Delivery"].dependsOn tasks["rmtGenerateStepCounter${varName}"]

        addTask("create${varName}Delivery", buildTypeName, flavorName)
    }
    
    //tasks.matching { task ->
    //    task.name.startsWith('rmt')
    //}*.group = 'RMT'

    println("-calculateLinesOfCode")
}

afterEvaluate {
    println "DELIVERY TASKS: ${createDeliveryTasks}"

    if (tasks.findByName("createDelivery") == null) {
        task("createDelivery") {
            group "rmtDelivery"
            dependsOn createDeliveryTasks.createAll
        }
    } else {
        println "Warning: It seems that createDelivery task is already defined!"
        tasks["createDelivery"].dependsOn createDeliveryTasks.createAll
    }

    createDeliveryTasks.createByBuildType.each { buildTypeName, deliveryTasks ->
        if (tasks.findByName("create${buildTypeName.capitalize()}Delivery") == null) {
            task("create${buildTypeName.capitalize()}Delivery") {
                group "rmtDelivery"
                dependsOn deliveryTasks
            }
        }
    }

    createDeliveryTasks.createByFlavor.each { flavorName, deliveryTasks ->
        if (tasks.findByName("create${flavorName.capitalize()}Delivery") == null) {
            task("create${flavorName.capitalize()}Delivery") {
                group "rmtDelivery"
                dependsOn deliveryTasks
            }
        }
    }

    /**
     * The built-in signingConfigs of the Android Gradle plugin only allows us
     * to sign our APK(s) once.
     *
     * The set of tasks below will allow us to sign our APK(s) multiple times
     * with different keys.
     *
     * To configure a project to use this signing method (instead of the built-in
     * one), we must define an extension in the target project named "jarSignerConfig".
     * This extension must be defined as a Map<String, Map<String, String>> where each
     * key in the map is a unique name of our signing config (must follow the variable
     * naming rules) and each value is another Map containing the settings of the
     * signing config, such as the keystore path, the key alias to be used, an the
     * store and key passwords.
     * 
     * Optionally, we can also add a boolean with the key "signNonDebugBuild" which will
     * determine whether or not non-debuggable build types (i.e. buildTypes with
     * "debuggable false") should also be signed.  By convention, non-debuggable types
     * are the release versions which are normally not signed by the build tool.
     * This value is false by default.
     *
     * Example:
     * ext {
     *     jarSignerConfig = [
     *         signNonDebugBuild: true,
     *         config1: [
     *             keystore: "path/to/my/keystore.ks",
     *             storePass: "keystorepassword",
     *             keyPass: "keypassword",
     *             alias: "keyalias"
     *         ],
     *         config2: [
     *             keystore: "path/to/my/second/keystore2.ks",
     *             storePass: "myPasswordIsAwesome",
     *             keyPass: "anotherAwesomePassword",
     *             alias: "anAwesomeAlias"
     *         ]
     *     ]
     * }
     *
     * The sample configuration above will cause all your debuggable and non-debuggable APK(s)
     * to be signed 2x with the keys defined in config1 and config2.
     *
     * Please note that using this signing method will overwrite any signature created
     * by the built-in signingConfigs.
     */
    if(project.hasProperty("jarSignerConfig")) {
        def signingTaskCount = 0
        def zipAlignExec = new File(new File(android.sdkDirectory, "build-tools/$android.buildToolsVersion"), "zipalign").absolutePath
        println("zipalign executable: $zipAlignExec")

        // Library projects do not have applicationVariants.
        // They have libraryVariants, which, we don't need to sign.
        if(project.android.hasProperty("applicationVariants")) {
            project.android.applicationVariants.all { variant ->
                def variantName = variant.name.capitalize()
                def returnVal = createSignApkTasks(project, variant, project.jarSignerConfig)
                String[] signingTasks = returnVal["signingTasks"]

                if(signingTasks.length > 0) {
                    Map<String, File> outputFiles = returnVal["outputFiles"]

                    task("rmtSignApk$variantName") {
                        group "rmt signer"
                        dependsOn signingTasks
                    }

                    signingTaskCount += signingTasks.length

                    if(variant.buildType.zipAlignEnabled) {
                        task("rmtZipAlign$variantName", type: Exec) {
                            dependsOn tasks["rmtSignApk$variantName"]

                            commandLine "\"$zipAlignExec\"", "-v",
                                    "-f", "4",
                                    "\"" + outputFiles["signedApk"].absolutePath + "\"",
                                    "\"" + outputFiles["alignedApk"].absolutePath + "\""
                        }

                        tasks["assemble$variantName"].dependsOn tasks["rmtZipAlign$variantName"]
                    } else {
                        tasks["assemble$variantName"].dependsOn tasks["rmtSignApk$variantName"]
                    }
                }
            }
        }

        // testVariants is present to both application and library projects
        project.android.testVariants.all { variant ->
            def variantName = variant.name.capitalize()
            def returnVal = createSignApkTasks(project, variant, project.jarSignerConfig)
            String[] signingTasks = returnVal["signingTasks"]

            if(signingTasks.length > 0) {
                Map<String, File> outputFiles = returnVal["outputFiles"]

                task("rmtSignApk$variantName") {
                    group "rmt signer"
                    dependsOn signingTasks
                }

                signingTaskCount += signingTasks.length

                if(variant.buildType.zipAlignEnabled) {
                    task("rmtZipAlign$variantName", type: Exec) {
                        dependsOn tasks["rmtSignApk$variantName"]

                        commandLine "\"$zipAlignExec\"", "-v",
                                "-f", "4",
                                "\"" + outputFiles["signedApk"].absolutePath + "\"",
                                "\"" + outputFiles["alignedApk"].absolutePath + "\""
                    }

                    tasks["assemble$variantName"].dependsOn tasks["rmtZipAlign$variantName"]
                } else {
                    tasks["assemble$variantName"].dependsOn tasks["rmtSignApk$variantName"]
                }
            }
        }

        if(signingTaskCount > 0) {
			println("")
            println("IMPORTANT NOTICE: Custom signing configurations (jarSignerConfig) were found for this project!")
            println("                  Any signature done by the built-in signer will be discarded and replaced with")
            println("                  those defined by jarSignerConfig.")
			println("")
        }
    }
}

/**
 * <p>
 * Retrieves the correct platform path (${sdkDirectory}/platforms/${platformDir}) that corresponds
 * to the given SDK/API version.
 *
 * @param sdkDirectory The root Android SDK path from where to search for the platform.
 * @param compileSdkVersion The SDK version to check (format: "android-${apiLevel}";
 *                          ex: "android-21" for Android Lollipop 5.0).
 * @return The platform path corresponding to the given SDK version.
 */
File getSdkPlatformFolder(File sdkDirectory, String compileSdkVersion) {
    def platformDir

    // Retrieve the list of folders, in SDK/platforms.
    def platformsDir = new File(sdkDirectory, "platforms")

    def platforms = platformsDir.listFiles()
    def numPlatforms = platforms.length

    def platformIndex = 0

    // Iterate through all the platforms subfolders
    for(; platformIndex < numPlatforms; platformIndex++) {
        platformDir = platforms[platformIndex]
        def propFile = new File(platformDir, "source.properties")

        println("Prop file: ${propFile}")

        // Check if ${sdkDirectory}/platforms/${platformDir}/source.properties exists
        if(propFile.exists() && propFile.isFile()) {
            def apiLevel = ""

            // If it exists, retrieve the value of the property, "AndroidVersion.ApiLevel"
            file(propFile).withReader { reader ->
                def sdkProps = new Properties()
                sdkProps.load(reader)
                apiLevel = sdkProps.getProperty("AndroidVersion.ApiLevel")
            }

            println("API level: ${apiLevel}")

            // If the value of "AndroidVersion.ApiLevel" matches the given version, then we've
            // found the platform folder.
            if("android-${apiLevel}".equalsIgnoreCase(compileSdkVersion.toString())) {
                break;
            }
        }
    }

    return platformDir
}

/**
 * Creates several tasks for signing an APK using the custom jarSignerConfig configuration.
 *
 * Returns a Map<String, Object> containing the following (key: value):
 *   signingTasks: String[] containing the names of the tasks that will perform the signing of the APK.
 *   outputFiles: Map<String, File> containing the output files where:
 *      unsignedApk: The file pointing to the unsigned APK
 *      signedApk: The file pointing to the signed (unaligned) APK
 *      alignedApk: The file pointing to the signed and aligned APK
 */
def createSignApkTasks(project, variant, jarSignerConfig) {
    def variantDebuggable = variant.buildType.debuggable
    def signNonDebugBuild = (jarSignerConfig["signNonDebugBuild"] == null) ? false : jarSignerConfig["signNonDebugBuild"]
    def configCount = jarSignerConfig.size() - (jarSignerConfig.containsKey("signNonDebugBuild") ? 1 : 0)

    def signingTasks = [];
    def outputFiles = new HashMap<>()

    // If the buildType is non-debuggable and jarSignerConfig is
    // not set to sign non-debug builds, then we don't create
    // any signing task for that build.

    if(variantDebuggable || signNonDebugBuild) {
        def variantName = variant.name.capitalize()

        def unsignedApk
        def signedApk
        def alignedApk

        variant.outputs.all { output ->
            // remove any "-unsigned", "-unaligned", "-signed" suffix in the file name
			def baseFile = outputFileName.replace("-unsigned.apk", ".apk").replace("-unaligned.apk", ".apk").replace("-signed.apk", ".apk")
			
			outputFileName = baseFile
			output.packageApplication.outputFile = file(baseFile.absolutePath.replace(".apk", "-unaligned.apk"))
		
			// The Android Gradle plugin uses the same file for the original input (unsigned APK)
			// and the final output (aligned APK)
            unsignedApk = output.outputFile
            signedApk = output.packageApplication.outputFile
            alignedApk = output.outputFile

            // Since this is actually a signed APK, remove the "-unsigned" suffix
            // and replace it with "-unaligned" which is currently the suffix used
            // by the Android Gradle plugin to mark an APK as signed (but not yet
            // aligned).
            // TODO: Please note that this may change in the future!
            if(signedApk.name.endsWith("-unsigned.apk")) {
                signedApk = file(signedApk.absolutePath.replace("-unsigned.apk", "-unaligned.apk"))
            }

            if(alignedApk.name.endsWith("-unsigned.apk")) {
                alignedApk = file(alignedApk.absolutePath.replace("-unsigned.apk", ".apk"))
            }
			
            if(alignedApk.name.endsWith("-unaligned.apk")) {
                alignedApk = file(alignedApk.absolutePath.replace("-unaligned.apk", ".apk"))
            }
			
            if(unsignedApk.name.endsWith("-unaligned.apk")) {
                unsignedApk = file(unsignedApk.absolutePath.replace("-unaligned.apk", ".apk"))
            }
			
			println("")
			println("Variant: $variantName")
			println("    unsignedApk: $unsignedApk")
			println("    signedApk: $signedApk")
			println("    alignedApk: $alignedApk")

            outputFiles = [
                    unsignedApk: unsignedApk,
                    signedApk: signedApk,
                    alignedApk: alignedApk
            ]

            // (1)
            // Copy the original signed APK into a temporary folder
            // (in "build\distributions"), removing the "META-INF"
            // inside the APK.
            // Removing the "META-INF" from the original APK is
            // necessary as it seems to prevent us from properly
            // re-signing the APK with JarSigner.
            def dependsOnTask
            def mustRunAfterTask

            if(output.zipAlign) {
                dependsOnTask = tasks["zipalign$variantName"]
                mustRunAfterTask = tasks["zipalign$variantName"]
            } else {
                dependsOnTask = tasks["package$variantName"]
                mustRunAfterTask = tasks["package$variantName"]
            }
			
			if(variantDebuggable) {
				task("rmtUnsignApk$variantName", type: Zip) {
					dependsOn dependsOnTask
					mustRunAfter mustRunAfterTask

					archiveName "$project.name${variantName}.apk"

					// The aligned APK may have the same name as the unsigned APK.
					// This is because the built-in tasks which perform the
					// signing overwrites the unsigned APK with the aligned
					// APK.  And since our tasks runs after the built-in
					// tasks, what we're referring to as the unsigned APK
					// may have already been signed and aligned by this time.
					from zipTree(signedApk)

					// If the input APK is indeed a signed APK, then,
					// remove the META-INF folder that contains the signature.
					exclude "META-INF/**"
				}
			} else {
				// If the variant is non-debuggable, it usually means it's a
				// release variant and so should not have a signed APK in the
				// first place.
				task("rmtUnsignApk$variantName", type: Zip) {
					dependsOn dependsOnTask
					mustRunAfter mustRunAfterTask

					archiveName "$project.name${variantName}.apk"

					// The aligned APK may have the same name as the unsigned APK.
					// This is because the built-in tasks which perform the
					// signing overwrites the unsigned APK with the aligned
					// APK.  And since our tasks runs after the built-in
					// tasks, what we're referring to as the unsigned APK
					// may have already been signed and aligned by this time.
					from zipTree(unsignedApk)

					// An unsigned APK should not have a META-INF folder, but
					// just to be sure, we still exclude it in case it's there.
					exclude "META-INF/**"
				}
			}

            // (2)
            // Delete the original unsigned, signed and aligned APKs from "build\outputs\apk".
            task("rmtDeleteSignedApk$variantName", type: Delete) {
                dependsOn tasks["rmtUnsignApk$variantName"]
                mustRunAfter tasks["rmtUnsignApk$variantName"]

                delete unsignedApk, signedApk, alignedApk
            }

            // (3)
            // Put the unsigned APK created in step (1) into "build\outputs\apk".
            task("rmtCopyUnsignedApk$variantName", type: Copy) {
                dependsOn tasks["rmtDeleteSignedApk$variantName"]
                mustRunAfter tasks["rmtDeleteSignedApk$variantName"]

                from "$project.buildDir/distributions/$project.name${variantName}.apk"
                into output.outputFile.parentFile

                rename file("$project.buildDir/distributions/$project.name${variantName}.apk").name,
                        unsignedApk.name
            }

            // (4)
            // Delete the temporary APK from the distributions folder
            task("rmtDeleteUnsingedApk$variantName", type: Delete) {
                dependsOn tasks["rmtCopyUnsignedApk$variantName"]
                mustRunAfter tasks["rmtCopyUnsignedApk$variantName"]

                delete file("$project.buildDir/distributions/$project.name${variantName}.apk")
            }

            // (5)
            // Create the input APK for JarSigner.
            // We will use signedApk as the input and output of JarSigner
            // so that we won't have to worry about input for multiple
            // JarSigner sessions.
            if(configCount > 0) {
                task("rmtCreateJarSignerInput$variantName", type: Copy) {
                    dependsOn tasks["rmtDeleteUnsingedApk$variantName"]
                    mustRunAfter tasks["rmtDeleteUnsingedApk$variantName"]

					doFirst {
						println("rmtCreateJarSignerInput$variantName> [src] unsignedApk: $unsignedApk")
						println("rmtCreateJarSignerInput$variantName> [dst] signedApk: $signedApk")
					}
					
                    from unsignedApk.absolutePath
                    into unsignedApk.parentFile

                    rename unsignedApk.name, signedApk.name

					doLast {
						println("rmtCreateJarSignerInput$variantName> [src] unsignedApk: $unsignedApk")
						println("rmtCreateJarSignerInput$variantName> [dst] signedApk: $signedApk")
					}
                }
            }
        }

        jarSignerConfig.each { config ->
            def configName = config.key.capitalize()

            if(!config.key.equals("signNonDebugBuild")) {
                // (6)
                // Sign the unsigned APK with the specified key using JarSigner.
                task("rmtSignApkWithJarSigner$configName$variantName", type: Exec) {
                    dependsOn tasks["rmtCreateJarSignerInput$variantName"]
                    mustRunAfter tasks["rmtCreateJarSignerInput$variantName"]

                    def keyStore = config.value["keystore"]
                    def storePass = config.value["storePass"]
                    def keyPass = config.value["keyPass"]
                    def alias = config.value["alias"]

                    doLast {
                        if(signedApk.exists()) {
                            println("Signed $signedApk.absolutePath")
                            println("    Keystore: $keyStore")
                            println("    Alias: $alias")
                        }
                    }

                    commandLine "jarsigner", "-verbose",
                            "-sigalg", "SHA1withRSA",
                            "-digestalg", "SHA1",
                            "-keystore", "\"$keyStore\"",
                            "-storepass", "\"$storePass\"",
                            "-keypass", "\"$keyPass\"",
                            "\"$signedApk.absolutePath\"",
                            "\"$alias\""
                }

                signingTasks << "rmtSignApkWithJarSigner$configName$variantName"
            }
        }
    }

    return [
            signingTasks: signingTasks,
            outputFiles: outputFiles
    ]
}

dependencies {
    yDoclet files(binFile("${COMMON_TOOLS}/javaDoc/yworks-doclet/lib/ydoc.jar"))
    yDoclet fileTree(binFile("${COMMON_TOOLS}/javaDoc/yworks-doclet/resources"))
}

def getAndroidGradlePluginVersion() {
    String version = "";

    // look for gradle-x.y.z.jar
    def gradleRegexp = /^gradle-([\d.]+).*\.jar/
    rootProject.buildscript.configurations.classpath.each { depFile ->
        if (depFile.name.matches(gradleRegexp)) {
            version = (depFile.name =~ gradleRegexp)[0][1]
        }
    }

    return version
}
// -------------------------------------------------------------------------------------------------
// END: CUSTOM SCRIPTS
// -------------------------------------------------------------------------------------------------
